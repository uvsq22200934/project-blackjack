#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = "Mathilde GAUTEUR, Maïlys VAUDEVIRE, Joseph ARIAS"
__copyright__ = "Copyright 2023, Projet Blacjack"
__credits__ = ["Mathilde GAUTEUR", "Maïlys VAUDEVIRE", "Joseph ARIAS"]
__license__ = "GPL"
__maintainer__ = "Joseph ARIAS"
__email__ = "joseph.arias@ens.uvsq.fr"
__status__ = "Developement"

import random
import tkinter
from PIL import Image, ImageTk
import _tkinter
import time

# Si debug == 1, alors les print sont effectifs. Si debug == 0, aucun print
# n'apparait
debug = 1

# Variable qui permet de savoir quand est-ce qu'un bouton a été appuyé pour la
# dernière fois
last_press = 0


# Listes et variables


# Ce dictionnaire permet de faire la correspondance entre une carte, et sa
# valeur
# p = pique, co = coeur, t = trèfle, ca = carreau
dic_valeur_cartes = {'2p': 2, '3p': 3, '4p': 4, '5p': 5, '6p': 6, '7p': 7,
                     '8p': 8, '9p': 9, '10p': 10, 'Vp': 10, 'Dp': 10,
                     'Rp': 10, 'Ap': 11,
                     '2co': 2, '3co': 3, '4co': 4, '5co': 5, '6co': 6,
                     '7co': 7, '8co': 8, '9co': 9, '10co': 10, 'Vco': 10,
                     'Dco': 10, 'Rco': 10, 'Aco': 11,
                     '2t': 2, '3t': 3, '4t': 4, '5t': 5, '6t': 6, '7t': 7,
                     '8t': 8, '9t': 9, '10t': 10, 'Vt': 10, 'Dt': 10,
                     'Rt': 10, 'At': 11,
                     '2ca': 2, '3ca': 3, '4ca': 4, '5ca': 5, '6ca': 6,
                     ' 7ca': 7, '8ca': 8, '9ca': 9, '10ca': 10, 'Vca': 10,
                     'Dca': 10, 'Rca': 10, 'Aca': 11}


# Le Blacjack se joue avec 6 paquets de 52 cartes, la variable paquet contient
# donc tous les paquets nécéssaires ppur le jeu
paquet = list(dic_valeur_cartes.keys())*6

# Les cartes jouées sont placées dans la défausse et ne seront remises en jeu
# que lorsque la carte rouge plus tard (les explications concernant la carte
# rouge se trouvent dans le commentaire suivant)
defausse = []

# La coupe correspond au nombre de carte qui vont être jouées avant que le
# croupier ne remélange le jeu. Dans la réalité, le croupier place une carte
# rouge dans le paquet de carte à un endroit aléatoire (il doit cependant y
# avoir au moins un jeu, soit 52 cartes, avant et apès la carte rouge). Dans le
# reste des commentaires du code, on parlera donc de carte rouge
coupe = random.randint(52, len(paquet)-52)

if debug == 1:
    print(coupe)

# Différentes main pour accueillir les cartes piochées
main_joueur = []
main_croupier = []

# Main utilisée lorsque le joueur fait un split
main_joueur_split = []


# Variables permettant au programme de savoir si le joueur a effectué
# certaines actions. Lorsque la variable vaut 0, l'action n'a pas été effectuée


# Split peut valoir 0, 1 ou 2. Si plit == 0, alors le joueur n'a pas fait de
# split. Si split == 1, alors le joueur a fait un split et joue sa première
# main. Si split == 2, le joueur joue sa deuxième main.
split = 0

# Blacjack peut valoir 0 ou 1 et permet de savoir si le joueur a fait un
# blackjack
blackjack = 0

# Assurance prise peut valoir 0 ou 1 et permet de savoir si le joueur a payé
# une assurance lorsque le croupier a révélé que sa première carte était un As
assurance_prise = 0

# Assurance gagnante peut valoir 0 ou 1 permet de savoir si l'assurance prise
# par le joueur est gagnate ou non, c'est à dire si le croupier avait
# effectivement un blackjack ou pas
assurance_gagnante = 0

# Variable qui permet de savoir si le joueur a cliqué sur play sur l'écran
# d'accueil
fenetre_jeu = 0


# Variables qui dépendent du joueur et/ou peuvent évoluer au cours de la partie
argent_joueur = 0
prix_assurance = 0
dette = 0
nom_joueur = ''
nombre_partie = 0
nombre_emprunt = 0


# Dictionnaires permettant de contourner le garbage collector
images = dict()
image_dos = dict()
image_tuto_dic = dict()


# Fonctions


def creer_image(carte, position_carte, texte):
    """Créer l'image d'une carte.

    Cette fonction sert à créer l'image de la carte sur l'interface graphique.

    Parametres
    ----------
    carte : str
        Le nom de la carte.
    position_carte : canvas
        Le canvas sur lequel l'image de la carte va s'afficher.
    texte : str
        Texte qui va créer une clé dans le dictionnaire dic_valeur_cartes pour
        eviter le garbage collector
    """
    image_carte = Image.open("./Images/cartes.png")
    if debug == 1:
        print('ok', carte)
    # A, B, C, D ont été mesurées au préalable et correspondent à l'écart entre
    # chaque carte sur l'image "cartes.png"
    A = 30
    B = 30
    C = 390
    D = 570
    # Si la carte est de la famille "coeur"
    if 'co' in carte:
        B += 570
        D += 570
    # Si la carte est de la famille "carreau"
    if 'ca' in carte:
        B += 570*2
        D += 570*2
    # Si la carte est de la famille "trèfle"
    if 't' in carte:
        B += 570*3
        D += 570*3
    for i in range(2, 11):
        # Si la valeur nominale de la carte est cimprise entre 2 et 10
        if str(i) in carte:
            A += 390 * (i-1)
            C += 390 * (i-1)
    # Si la carte est un Valet
    if 'V' in carte:
        A += 390*10
        C += 390*10
    # Si la carte est une Dame
    if 'D' in carte:
        A += 390*11
        C += 390*11
    # Si la carte est un Roi
    if 'R' in carte:
        A += 390*12
        C += 390*12
    # On notera que si la carte est un As, aucune valeur n'est incrémentée à A
    # et C et que si la carte est un pique, aucune valeur n'es incrémentée à B
    # et D. C'est parce que A et C correspondent au pixel le plus à droite et
    # au pixel le plus à gauche de la carte qui sont les mêmes pour tous les
    # As et corrspondent et valeurs A et C initiales. Il en va de même pour C
    # et D qui correspondent au pixel le plus haut et celui le plus bas de la
    # carte qui sont les mêmes pour tous les piques et corrspondent et valeurs
    # B et D initiales.
    if debug == 1:
        print(A, B, C, D)
    crop_rectangle = (A, B, C, D)
    cropped_im = image_carte.crop(crop_rectangle)
    # image_fin permet de faire correspondre la taille de l'image à la taille
    # du canva qui va l'accueillir
    image_fin = cropped_im.resize((66, 100))
    # L'ajout de "texte" au doctionnaire image permet d'éviter le garbage
    # collector
    images[texte] = ImageTk.PhotoImage(image_fin)
    position_carte.create_image(2, 2, anchor='nw', image=images[texte])


def dos_carte(position, texte):
    """Créer l'image du dos des cartes.

    Cette fonction sert à créer l'image de du dos des carte sur l'interface
    graphique.

    Parametres
    ----------.
    position : canvas
        Le canvas sur lequel l'image de la carte va s'afficher.
    texte : str
        Texte qui va créer une clé dans le dictionnaire dic_valeur_cartes pour
        eviter le garbage collector
    """
    image_carte = Image.open("./Images/dos_cartes3.jpg")
    image_fin = image_carte.resize((66, 100))
    images[texte] = ImageTk.PhotoImage(image_fin)
    position.create_image(2, 2, anchor='nw', image=images[texte])


def debut(event):
    """Débuter la partie.

    Cette fonction sert à afficher la fenêtre correspondant au jeu lorsque
    l'on appuie sur le bouton play.

    Parametres
    ----------.
    event
    """
    global nom_joueur
    global argent_joueur
    global fenetre_jeu
    if event.widget == play:
        nom_joueur = entree_username.get()
        argent_joueur = entree_credit.get()
        # Si le joueur n'a pas entré un nombre compris entre 0 et 1 000 000 000
        # exclus
        if not argent_joueur.isdigit() or int(argent_joueur) <= 0 or\
                len(argent_joueur) > 10:
            # Si la fonction pack_info retourne une erreur Tcl, alors le
            # message d'erreur n'est pas encore pack et donc le programme le
            # pack. Cela permet de ne pas pack plusieurs fois le message
            # d'erreur
            try:
                erreur_argent.pack_info()
            except _tkinter.TclError:
                erreur_argent.pack()
        else:
            erreur_argent.pack_forget()
        # Si le nom du joueur fait plus de 15 caractère et/ou n'est consitué
        # que d'espaces
        if len(nom_joueur) > 15 and len(nom_joueur.strip()) != 0:
            try:
                erreur_nom.pack_info()
            except _tkinter.TclError:
                erreur_nom.pack()
        else:
            erreur_nom.pack_forget()
        # Si le joueur n'entre pas de nom, il est nommé 'Player' par défaut
        if nom_joueur == '':
            nom_joueur = 'Player'
        if argent_joueur == '':
            argent_joueur = '1000'
        # On vérifie que le joueur ai bien rentré un texte uniquement composé
        # de chiffres et que le nombre soit compris entre 0 et 1 000 000 000
        # exclus
        if argent_joueur != '' and argent_joueur.isdigit():
            print('ok ca marhve', argent_joueur)
            argent_joueur = int(argent_joueur)
        # On vérifie avant de lancer la fenêtre de jeu que le joueur ai bien
        # rentré un crédit uniquement composé de chiffre et que son nom ne
        # soit pas trop long ni constitué uniquement d'espaces
        if argent_joueur != '' and nom_joueur != '' and\
                str(argent_joueur).isdigit() and len(nom_joueur) < 15 and\
                len(str(argent_joueur)) <= 10 and argent_joueur > 0 and\
                len(nom_joueur.strip()) != 0:
            argent['text'] = 'Crédits: '+str(argent_joueur)
            accueil.pack_forget()
            root.pack(fill=tkinter.BOTH, expand=True)
            fenetre_jeu = 1


def donne_initiale():
    """Donne initiale des cartes aux joueurs et au croupier.

    Cette fonction sert à distribuer deux cartes à tous les joueurs et au
    croupier lorsque la manche débute
    """
    global paquet
    global main_joueur
    global main_croupier
    global blackjack
    global assurance_prise
    global mise_totale
    global nombre_partie
    disparition_mise()
    bouton_donne_initiale.grid_forget()
    nb_carte_piochee = 0
    # Le joueur pioche 1 carte puis le croupier en fait de même jusqu'à ce
    # qu'ils aient 2 cartes chacun
    while nb_carte_piochee < 2:
        main_joueur.append(paquet[0])
        del paquet[0]
        nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le ' +\
            f'paquet: {str(len(paquet))} \nNombre de cartes restantes ' +\
            f'dans la défausse: {str(len(defausse))}'
        main_croupier.append(paquet[0])
        del paquet[0]
        nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le ' +\
            f'paquet: {str(len(paquet))} \nNombre de cartes restantes ' +\
            f'dans la défausse: {str(len(defausse))}'
        nb_carte_piochee += 1
    nombre_partie += 1
    # cj signifie carte joueur, le numéro sert à l'indentifier par rapport aux
    # autres cartes du joueur
    creer_image(main_joueur[0], cj['cj1'], 'cj1')
    # Les différents root.after du programme servent à ne faire apparaitre les
    # cartes qu'après 0,5 seconde pour rendre le jeu plus naturel. Ils n'ont
    # donc qu'un but purement décoratif
    root.after(500, root.update())
    # cc signifie carte croupier, le numéro sert à l'indentifier par rapport
    # aux autres cartes du croupier
    creer_image(main_croupier[0], cc['cc1'], 'cc1')
    root.after(500, root.update())
    creer_image(main_joueur[1], cj['cj2'], 'cj2')
    root.after(500, root.update())
    dos_carte(cc['cc2'], 'cc2')
    if 'A' in main_croupier[0]:
        if debug == 1:
            print('As détecté')
        prix_assurance = mise_totale // 2
        if argent_joueur >= prix_assurance:
            texte_assurance['text'] = 'Le Dealer vient de tirer un ' + \
                f'As. Voulez vous payer une assurance ({prix_assurance})?'
            texte_assurance.grid(column=2, row=3)
            bouton_oui_assurance.grid(column=2, row=4)
            bouton_non_assurance.grid(column=2, row=5)
            root.update()
        else:
            if score(main_joueur) == 21:
                blackjack = 1
                croupier()
            else:
                bouton_melanger.grid_forget()
                apparition_bouton_joueur()
    else:
        if score(main_joueur) == 21:
            blackjack = 1
            croupier()
        else:
            bouton_melanger.grid_forget()
            apparition_bouton_joueur()
    if debug == 1:
        print('main joueur', main_joueur, '\n main croupier', main_croupier)


def reponse_assurance(reponse=0):
    """Réaction suite à la réponse du joueur concernant l'assurance.

    Cette fonction sert à déterminer si le joueur prend ou non l'assurance

    Parametres
    ----------.
    reponse : str
        Permet de déterminer si le joueur prend l'assurance ou non
    """
    global argent_joueur
    global assurance_prise
    global bouton_non_assurance
    global bouton_oui_assurance
    global blackjack
    global mise_totale
    global last_press
    # Si un bouton a été pressé il y a moins de 0.5 secondes
    if time.time() - last_press < 0.5:
        # La fonction s'arrête immédiatement
        return
    else:
        # Sinon on relève le temps où le bouton a été pressé pour éviter un
        # spam qui "casserait" le programme
        last_press = time.time()
    prix_assurance = mise_totale // 2
    # Si le joueur souhaite prendre l'assurance
    if reponse == 'oui':
        argent_joueur -= prix_assurance
        assurance_prise = 1
        assurance_valeur['text'] = f'Assurance: {str(prix_assurance)}'
        assurance_valeur.grid(column=0, row=10)
    bouton_non_assurance.grid_forget()
    bouton_oui_assurance.grid_forget()
    texte_assurance.grid_forget()
    argent['text'] = f'Crédits: {str(argent_joueur)}'
    # Si le joueur a un blacjack
    if score(main_joueur) == 21:
        blackjack = 1
        croupier()
    if blackjack == 0:
        bouton_melanger.grid_forget()
        apparition_bouton_joueur()


def hit(main, pointeur):
    """Hit.

    Cette fonction sert à faire piocher une carte lorsque le joueur ou le
    croupier "hit".

    Parametres
    ----------.
    main : list
        Correspond à la main qui va piocher la carte
    pointeur : str
        Permet de savoir si c'est le croupier qui pioche ou un joueur
    """
    global main_joueur
    global main_croupier
    global paquet
    global last_press
    if time.time() - last_press < 0.5:
        return
    else:
        last_press = time.time()
    if split == 2 and main != main_croupier:
        # cja correspond à la liste de canvas utilisée pour afficher les
        # cartes de la deucime main du joueur en cas de split
        carte = cja
        main = main_joueur_split
    else:
        carte = cj
    if pointeur == 'main_joueur':
        bouton_double_down.grid_forget()
        bouton_split.grid_forget()
        bouton_surrender.grid_forget()
        main.append(paquet[0])
        del paquet[0]
        nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le ' +\
            f'paquet: {str(len(paquet))} \nNombre de cartes restantes ' +\
            f'dans la défausse: {str(len(defausse))}'
        for i in range(3, 14):
            if len(main) == i:
                if main == main_joueur:
                    creer_image(main[i-1], carte[f'cj{i}'],
                                f'cj{i}')
                    carte[f'cj{i}'].grid(column=4+i, row=7)
                if main == main_joueur_split:
                    creer_image(main[i-1], carte[f'cj{i}a'],
                                f'cj{i}a')
                    carte[f'cj{i}a'].grid(column=4+i, row=8)
        # On vérifie que le joueur n'ai pas de Blackjack
        test_score(main)
    if pointeur == 'main_croupier':
        carte = cc
        if debug == 1:
            print(len(main))
        main.append(paquet[0])
        del paquet[0]
        nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le ' +\
            f'paquet: {str(len(paquet))} \nNombre de cartes restantes ' +\
            f'dans la défausse: {str(len(defausse))}'
        for i in range(3, 14):
            if len(main) == i:
                creer_image(main[i-1], carte[f'cc{i}'], f'cc{i}')
                root.after(500, root.update())
                carte[f'cc{i}'].grid(column=4+i, row=1)
    root.update()


def test_score(main):
    """Tester le score d'une main.

    Cette fonction sert à vérifier qu'une main d'un joueur ne vale pas ou ne
    dépasse pas 21 points. Si c'est le cas, aucune action supplémentaire du
    joueur ne peut avoir lieu sur la main en question

    Parametres
    ----------.
    main : list
        Correspond à la main dont le socre est testé
    """
    global split
    if score(main) >= 21:
        if split == 1:
            if debug == 1:
                print('apparition main 2 dans test score')
            numero_main['text'] = 'Main 2'
            split = 2
        else:
            croupier()


def disparition_bouton_joueur():
    """Réaction suite à la réponse du joueur concernant l'assurance.

    Cette fonction sert à faire disparaitre de l'interface graphique les
    boutons qu'utilise le joueur pour déterminer quelle action il effectue vis
    à vis de sa main
    """
    global bouton_hit
    if debug == 1:
        print("bouton test", bouton_hit.grid_info())
    for i in range(len(bouton_joueur)):
        bouton_joueur[i].grid_forget()
    bouton_split.grid_forget()


def fin_manche():
    """Ramassage des cartes en fin de manche.

    Cette fonction sert à enlever les cartes des différentes main et les
    placer dans la défausse
    """
    global main_croupier
    global main_joueur
    global main_joueur_split
    global defausse
    disparition_bouton_joueur()
    while len(main_joueur) != 0:
        defausse.append(main_joueur[0])
        del main_joueur[0]
    while len(main_croupier) != 0:
        defausse.append(main_croupier[0])
        del main_croupier[0]
    while len(main_joueur_split) != 0:
        defausse.append(main_joueur_split[0])
        del main_joueur_split[0]
    if debug == 1:
        print(len(paquet), paquet)
        print('mains croupier ', main_croupier, 'main joueur', main_joueur)
    bouton_rejouer.grid(column=2, row=3)


def score(main):
    """Score d'une main.

    Cette fonction sert à déterminer quel est le score d'une main

    Parametres
    ----------.
    main : list
        Correspond à la main dont le score est évalué
    """
    points = 0
    # Pour chauque carte dans la main, on évalue combien de point elle vaut en
    # se référant au dictionnaire de valeur des cartes
    for element in main:
        points += dic_valeur_cartes.get(element)
        if debug == 1:
            print(points, dic_valeur_cartes.get(element), element)
    boucle = 0
    while points > 21:
        # condition pour éviter que la boucle ne tourne à l'infini
        if boucle > len(main)-1:
            break
        # Si la main vaut plus que 21 points et que la main contient un As,
        # alors l'As vaut 1 au lieu de 11 ce qui équivaut à enlever 11 points
        # à la main puique l'As a déjà était comptabilisé et évalué à 11 points
        # plus haut dans la fonction. Pour être sûr que chaque As ne soit
        # compté qu'une seule fois, on vérifie si chaque carte est un As ou pas
        if 'A' in main[boucle]:
            points -= 10
        boucle += 1
    if debug == 1:
        print('point final', points)
    return points


def croupier():
    """Action du croupier

    Cette fonction sert à faire jouer le croupier: il pioche des carte
    jusqu'à avoir 17 points ou plus
    """
    global main_croupier
    numero_main.grid_forget()
    creer_image(main_croupier[1], cc['cc2'], 'cc2')
    cc['cc2'].grid(column=3, row=1)
    root.update()
    points_croupier = score(main_croupier)
    while score(main_croupier) <= 16:
        if debug == 1:
            print(points_croupier, main_croupier)
        hit(main_croupier, 'main_croupier')
    if debug == 1:
        print('resultat dans croupier')
    resultat()


def stand():
    """Stand.

    Cette fonction permet au joueur de stand, c'est à dire d'arreter de
    piocher des cartes et garder sa main en l'état actuel
    """
    global split
    global last_press
    if time.time() - last_press < 0.5:
        return
    else:
        last_press = time.time()
    stand_label.grid(column=10, row=5)
    bouton_split.grid_forget()
    if debug == 1:
        print("je m'arrête", split)
    # Si le joueur n'a pas split ou si le joueur a split et joué ses deux mains
    if split == 0 or split == 2:
        croupier()
        disparition_bouton_joueur()
    if split == 1:
        split = 2
        numero_main['text'] = 'Main 2'


def doubble_down(main):
    """Doubble down

    Cette fonction sert à réagir lorsque le joueur doubble down: il double sa
    mise, reçois une carte, puis sont tour s'arrête

    Parametres
    ----------.
    main : list
        Correspond à la main qui double down
    """
    global mise_totale
    global argent_joueur
    global split
    global last_press
    if time.time() - last_press < 0.5:
        return
    else:
        last_press = time.time()
    bouton_split.grid_forget()
    argent_joueur -= mise_totale
    mise_totale *= 2
    mise_texte['text'] = f"Mise totale: {str(mise_totale)}"
    argent['text'] = f'Crédits: {str(argent_joueur)}'
    hit(main, 'main_joueur')
    if debug == 1:
        print(main)
    if split == 1:
        split = 2
        numero_main['text'] = 'Main 2'
    else:
        croupier()


def surrender():
    """Surrender.

    Cette fonction permet au joueur de "surrender", il abandonne la manche
    avant de piocher une carte et récupère la moitié de sa mise.
    """
    global split
    global last_press
    if time.time() - last_press < 0.5:
        return
    else:
        last_press = time.time()
    bouton_split.grid_forget()
    if split == 1:
        split = 2
        numero_main['text'] = 'Main 2'
    else:
        resultat(action='surrender')


def resultat(action=0):
    """Résultat de la manche

    Cette fonction sert à donner le résulat de la manche

    Parametres
    ----------.
    action : str
        Permet de savoir si le joueur a surrender ou pas
    """
    global main_croupier
    global assurance_prise
    global assurance_gagnante
    global blackjack
    global split
    resultat_label['text'] = ''
    taille_main_croupier = len(main_croupier)
    # Les scores du croupier et du joueur sont assignés à des variables afin
    # de n'avoir à passer une seule fois par main dans la fonction score
    score_croupier = score(main_croupier)
    score_joueur = score(main_joueur)
    # Consequence est une variable permettant de savoir quel gain donner dans
    # la fonction calcul_gain
    consequence = 0
    boucle = 1
    if debug == 1:
        print('Entrée résultat')
    if split != 0:
        resultat_label['text'] = 'Main 1 \n'
        boucle = 2
    # La boucle permet de prendre en compte le résultat des deux main si le
    # joueur a split
    while boucle != 0:
        if debug == 1:
            print('boucle')
        # Split peut effectivement être égal à 1 dans cette fonction car il
        # est décrémenter à la fin de la boucle while afin de bien calculer le
        # résultat des deux mains du joueur
        if split == 1:
            score_joueur = score(main_joueur_split)
        # Si le joueur a un blackjack
        if blackjack == 1:
            if debug == 1:
                print('taille main croupier', taille_main_croupier,
                      main_croupier, score_croupier)
            # Si le croupier a également un blackjack
            if (score_croupier == 21) and (taille_main_croupier == 2):
                resultat_label['text'] += 'Vous et le Dealer avez un ' + \
                    'Blacjack: ex aequo'
                consequence = 'egalite'
            # Si le croupier n'a pas de Blacjack
            else:
                resultat_label['text'] += 'BLACKJACK: vous êtes le vainqueur'
                consequence = 'Blackjack'
        # Si le joueur a surrender
        elif action == 'surrender':
            resultat_label['text'] += 'Vous avez abandonné'
            consequence = 'ff'
        # Si le joueur a dépassé 21 points
        elif score_joueur > 21:
            resultat_label['text'] += 'Votre main vaut plus que 21, vous' + \
                ' avez perdu.'
        # Si le joueur a 21 points ou moins
        elif score_joueur <= 21:
            # Si le croupier a dépassé 21 points
            if score_croupier > 21:
                resultat_label['text'] += 'Le Dealer a dépassé 21: vous ' +\
                    'avez gagné !'
                consequence = 'win'
            # Si le croupier a 21 points ou moins
            elif score_croupier <= 21:
                # Si le croupier a fait un blackjack
                if (score_croupier == 21) and (taille_main_croupier == 2):
                    if debug == 1:
                        print('ok')
                    resultat_label['text'] += 'Le Dealer a fait un ' +\
                        ' BlackJack !\n'
                    # Si le joueur a lui aussi fait un blackjack, à noter
                    # qu'on ne peut pas faire de blackjack après un split
                    if score_joueur == 21 and len(main_joueur) == 2 \
                            and split == 0:
                        resultat_label['text'] += 'Vous avez également un ' +\
                            'BlackJack, votre mise est remboursée \n'
                        consequence = 'egalite'
                    # Si le joueur a pris l'assurance
                    if assurance_prise == 1:
                        resultat_label['text'] += 'Vous avez payé l\'' +\
                            'assurance, vous gagnez deux fois le montant ' +\
                            'de votre assurance \n'
                        assurance_gagnante = 1
                    # Si le joueur n'a pas de Blackjack
                    if score_joueur != 21 or len(main_joueur) != 2:
                        resultat_label['text'] += ' La main du Dealer ' +\
                            'est meilleure, vous avez perdu.e'
                # Si le joueur a un moins bon score que le croupier
                elif score_joueur < score_croupier:
                    resultat_label['text'] += 'Le Dealer a un meilleur ' + \
                        'score, vous avez perdu.'
                # Si le joueur a le même score que le croupier
                elif score_joueur == score_croupier:
                    resultat_label['text'] += 'Vous avez le même score ' + \
                        'que le Dealer: ex aequo'
                    consequence = 'egalite'
                # Si le joueur a un meilleur score que le croupier
                elif score_joueur > score_croupier:
                    resultat_label['text'] += 'Vous avez un meilleur ' +\
                        'score que le Dealer: vous avez gagné !'
                    consequence = 'win'
        if split == 0:
            annonce = f'Votre score: {str(score_joueur)} \n Score' + \
                f' du Dealer: {str(score_croupier)} \n'
        # Si le joueur a fait un split, l'affichage lié au résultat est
        # différent que s'il n'y avait pas eu de split afin d'afficher les
        # résultats des différentes mains
        if split == 2:
            annonce = f'Score main 1: {str(score_joueur)}\n'
            resultat_label['text'] += '\n Main 2 \n'
        if split == 1:
            annonce += f'Score main 2: {str(score_joueur)}\n' + \
                f'Score du Dealer: {str(score_croupier)} \n'
        resultat_final['text'] = annonce
        resultat_final.grid(column=6+len(main_croupier), row=3)
        resultat_label.grid(column=6+len(main_croupier), row=2)
        if debug == 1:
            print(score_joueur, score_croupier)
            print('fin manche dans resultat')
        boucle -= 1
        if split != 0:
            # La désincrémetation de split permet de calculer la deuxième main
            # du joueur
            split -= 1
        calcul_gain(consequence, assurance_gagnante)


def calcul_gain(consequence=0, assurance_gagnante=0):
    """Calcul des gains

    Cette fonction sert à calculer les gains en fonction du résultat

    Parametres
    ----------.
    consequence : str
        Permet de déterminer combien le joueur a remporté en fonction du
        résultat
    assurance_gagnante : int
        Si le paramètre vaut 1, alors le joueur a pris l'assurance lorsqu'il a
        été dévoilé que la première carte du croupier était un As et le
        croupier a effectivement eu un blackjack
    """
    global mise_totale
    global argent_joueur
    if debug == 1:
        print('début calcul gain')
    # gain correspond à l'argent gagné grâce à la main
    gain = 0
    # gain assurance correspond à l'argent gagnée si le joueur a pris
    # l'assurance et que le croupier avait effectivement un blackjack
    gain_assurance = 0
    # Si le joueur n'a ni perdu ni abandonnée, il regagne sa mise de départ
    if consequence != 0 and consequence != 'ff':
        if debug == 1:
            print('mise remboursée')
        argent_joueur += mise_totale
        argent['text'] = f'Crédits: {int(argent_joueur)}'
    # Gain en cas de blackjack
    if consequence == 'Blackjack':
        gain += mise_totale * 1.5
    # Remboursement de la moitié de la mise en cas d'abandon
    if consequence == 'ff':
        gain += mise_totale // 2
    # Gain en cas de main meilleure que celle du croupier
    if consequence == 'win':
        gain += mise_totale
    # Gain relatif à l'assurance
    if assurance_gagnante == 1:
        gain_assurance += mise_totale
    gain = int(gain)
    if gain != 0:
        argent['text'] = f'Crédits: {int(argent_joueur)} + {int(gain)}'
    else:
        argent['text'] = f'Crédits: {int(argent_joueur)}'
    if gain_assurance != 0:
        argent['text'] += f' + {int(gain_assurance)}'
    argent_joueur += gain + gain_assurance
    # on vérifie si le joueur est en capacité de rembourser sa dette, c'est à
    # dire est qu'il possède le double du montant de sa dette
    test_dette()
    if debug == 1:
        print('fin calcul gain')
    if split == 0:
        fin_manche()


def splitter():
    """Splitter.

    Cette fonction permet au joueur de jouer deux main au lieu d'une seule si
    les deux premieres cartes reçues forment une paire. Si la paire en
    question est une paire d'As, le joueur ne reçois qu'une carte dans chacune
    des deux main et ne peut pas avoir de Blackjack
    """
    global split
    global last_press
    if time.time() - last_press < 0.5:
        return
    else:
        last_press = time.time()
    split = 1
    bouton_split.grid_forget()
    # cj1a et cj2a correspondent aux canvas permettant d'afficher sur
    # l'interface graphique des deux premières carte de la deuxième main du
    # joueur
    cja['cj1a'].grid(column=1, row=8)
    cja['cj2a'].grid(column=3, row=8)
    # La deuxième carte de la deuxième main disparait sur l'interface
    # graphique puisque correspondant désoirmais à la première carte de la
    # deuxième main
    cj['cj2'].delete('all')
    main_joueur_split.append(main_joueur[1])
    del main_joueur[1]
    main_joueur.append(paquet[0])
    del paquet[0]
    nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le paquet:' +\
        f' {str(len(paquet))} \nNombre de cartes restantes dans la ' +\
        f' défausse: {str(len(defausse))}'
    main_joueur_split.append(paquet[0])
    del paquet[0]
    nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le paquet:' +\
        f' {str(len(paquet))} \nNombre de cartes restantes dans la ' +\
        f' défausse: {str(len(defausse))}'
    creer_image(main_joueur_split[0], cja['cj1a'], 'cj1a')
    root.after(500, root.update())
    creer_image(main_joueur[1], cj['cj2'], 'cj2')
    root.after(500, root.update())
    creer_image(main_joueur_split[1], cja['cj2a'], 'cj2a')
    root.after(500, root.update())
    numero_main.grid(column=2, row=1)
    # Si le joueur a une paire d'as et qu'il split, il ne peut avoir que 2
    # cartes par main, as inclu. Son tour se finit donc automatiqument après
    # avoir reçu une carte supplémentaire par main
    if 'A' in main_joueur[0] and 'A' in main_joueur_split[0]:
        split = 2
        croupier()
    else:
        numero_main['text'] = 'Main 1'


def rejouer():
    """Rejouer.

    Cette fonction permet au joueur de jouer une nouvelle manche et fait
    disparaître les cartes ainsi que les différents textes qui apparaissent à
    la fin d'une manche. Si le nombre de cartes jouées est supérieur à la
    valeur de la coupe, alors le paquet et la défausse sont mis en commun et
    le nouveau paquet obtenu remélangé
    """
    global mise_totale
    global coupe
    global blackjack
    # cc correspond à la liste de canvas permettant l'affichage des cartes du
    # croupier sur l'interface graphique
    global cc
    # cc correspond à la liste de canvas permettant l'affichage des cartes du
    # joueur sur l'interface graphique
    global cj
    global cja
    global last_press
    if time.time() - last_press < 0.5:
        return
    else:
        last_press = time.time()
    blackjack = 0
    nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le paquet:' +\
        f' {str(len(paquet))} \nNombre de cartes restantes dans la' +\
        f' défausse: {str(len(defausse))}'
    # Si la carte rouge a été tirée
    if len(defausse) >= coupe:
        # Le reste du paquet et la défausse sont mis en commun
        for i in range(len(defausse)):
            paquet.append(defausse[0])
            del defausse[0]
            nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le ' +\
                f'paquet: {str(len(paquet))} \nNombre de cartes restantes ' +\
                f'dans la défausse: {str(len(defausse))}'
        # Le paquet est remélangé et la carte rouge replacée dans ce dernier
        random.shuffle(paquet)
        coupe = random.randint(52, len(paquet)-52)
    bouton_rejouer.grid_forget()
    apparition_mise()
    bouton_donne_initiale.grid(column=2, row=3)
    mise_totale = 0
    mise_texte['text'] = "Mise totale: "
    argent['text'] = f'Crédits: {str(argent_joueur)}'
    # Les images des cartes disparaissent des l'interface graphqiue
    cc['cc1'].delete('all')
    cc['cc2'].delete('all')
    cj['cj1'].delete('all')
    cj['cj2'].delete('all')
    for i in range(3, 22):
        cc[f'cc{i}'].grid_forget()
        cj[f'cj{i}'].grid_forget()
    for i in range(0, 22):
        cja[f'cj{i}a'].grid_forget()
        cja[f'cj{i}a'].delete('all')
    resultat_label.grid_forget()
    resultat_final.grid_forget()
    assurance_valeur.grid_forget()
    stand_label.grid_forget()
    # Si le joueur n'a plus d'argent il lui est proposé de prendre un emprunt
    if argent_joueur == 0:
        emprunt.grid(column=9, row=5)
        term.grid(column=10, row=5)
        banque.grid(column=9, columnspan=5, row=3)


def quitter(event):
    """Quitter le jeu.

    Cette fonction permet au joueur de quitter le jeu et ferme la fenêtre du
    jeu
    """
    window.destroy()



# Les deux fonctions qui suivent servent à déterminer l'ordre d'appartion des
# widgets dans la fenêtre de jeu


def ordre_boutons2(event):
    if event.widget == bouton_melanger:
        bouton_melanger.grid_forget()
        bouton_donne_initiale.grid(column=2, row=3)
        apparition_mise()


def ordre_boutons3(event):
    if event.widget == bouton_donne_initiale:
        if mise_totale != 0:
            erreur.grid_forget()
            if debug == 1:
                print('ok')
            donne_initiale()
        else:
            bouton_donne_initiale.grid_forget()
            erreur.grid(column=2, row=3)
            erreur.lift()
            erreur['text'] = 'Veuillez miser pour jouer'


def apparition_bouton_joueur():
    """Apparition des boutons du joueur

    Cette fonction permet de faire apparaître sur l'interface graphique les
    boutons du joueur reltaifs aux actions qu'il peut effectuer vis à vis de
    sa main
    """
    global argent_joueur
    bouton_hit.grid(column=2, row=3)
    stand_bouton.grid(column=2, row=5)
    bouton_surrender.grid(column=2, row=6)
    # L'option double down n'est proposée au joueur que s'il possède encore
    # assez d'argent pour miser une seconde fois la même mise que la mise
    # qu'il vient de faire
    if argent_joueur >= mise_totale:
        bouton_double_down.grid(column=2, row=4)
    # Si les deux premières cartes du joueur forment une paire et qu'il
    # possède assez d'argent pour miser une seconde fois la même mise que la
    # mise qu'il vient de faire, il lui est proposé de splitter sa main
    if main_joueur[0][0] == main_joueur[1][0] and argent_joueur >= mise_totale:
        bouton_split.grid(column=2, row=7)
        argent_joueur -= mise_totale
        mise_texte['text'] == f'Mise main 1: {mise_totale} \n' +\
            f'Mise main 2: {mise_totale}'


def apparition_mise():
    """Apparition des mises

    Cette fonction permet de faire apparaitre les différents jetons relatifs
    aux mises sur l'interface graphique
    """
    jeton_blanc.grid(column=4, row=10)
    jeton_bleu.grid(column=3, row=10)
    jeton_rouge.grid(column=2, row=10)
    jeton_noir.grid(column=6, row=10)
    jeton_vert.grid(column=1, row=10)
    jeton_tapis.grid(column=7, row=10)
    miser.grid(column=0, row=10)
    mise_texte.grid(column=0, row=9)


def disparition_mise():
    """Disparition des mises

    Cette fonction permet de faire disparître les jetons relatifs aux mises
    sur l'interface graphique une fois que la manche a commencée
    """
    for i in range(len(jeton_et_mise)):
        jeton_et_mise[i].grid_forget()


def mise(montant_mise):
    """ Mise

    Cette fonction permet de comptabiliser la mise du joueur

    Parametres
    ----------.
    montant_mise: int
        Détermine de combien la mise doit être incrémentée
    """
    global mise_totale
    global argent_joueur
    if (argent_joueur - montant_mise) >= 0:
        erreur.grid_forget()
        bouton_donne_initiale.grid(column=2, row=3)
        mise_totale += montant_mise
        argent_joueur -= montant_mise
        mise_texte['text'] = f"Mise totale: {str(mise_totale)}"
        argent['text'] = f'Crédits: {str(argent_joueur)}'


def emprunter(event):
    """ Emprunt

    Cette fonction permet au joueur de faire un emprunt de crédit à la banque
    pour continuer de jouer
    """
    global argent_joueur
    global nombre_emprunt
    if event.widget == emprunt:
        nombre_emprunt += 1
        term.grid_forget()
        emprunt.grid_forget()
        valid.grid(column=9, columnspan=5, row=6)
        my_entry3.grid(column=9, columnspan=5, row=5)


def validd(event):
    """ Valider le montant de l'emprunt

    Cette fonction permet de valider le montant de l'emprunt effectué par le
    joueur et d'afficher une erreur si la saisie est hors du cadre requis
    """
    global argent_joueur
    global dette
    if event.widget == valid:
        global last_press
        if time.time() - last_press < 0.5:
            return
        else:
            last_press = time.time()
        argent_demande = my_entry3.get()
        if argent_demande != int or int(argent_demande) <= 0 or\
                len(argent_demande) >= 3:
            entry_label['text'] = 'Erreur\n Veuillez entrer' +\
                ' un nombre entier positif inférieur à 999'
            entry_label.grid(column=9, columnspan=5, row=7)
        if argent_demande.isdigit() and int(argent_demande) > 0 and\
                len(argent_demande) <= 3:
            if debug == 1:
                print(entry_label.grid_info())
            argent_joueur += int(my_entry3.get())
            argent['text'] = f'Crédits: {str(argent_joueur)}'
            dette += int(my_entry3.get())
            dette_label['text'] = f'Vous avez {str(dette)} € de dettes ' +\
                'envers la banque'
            dette_label.grid(column=9, columnspan=5, row=1)
            for i in range(len(canvas_emprunt)):
                canvas_emprunt[i].grid_forget()


def test_dette():
    """ Vérifier combien le joueur a d'argent

    Cette fonction permet de vérifier si le joueur possède une somme au moins
    égale au double du montant de sa dette et la rembourse automatiquement si
    tel est le cas
    """
    global argent_joueur
    global dette
    if debug == 1:
        print('dette remboursable')
    # Vérifie que le joueur possède au moins le double du montant de la dette
    # et que le joueur est effectiement endettée
    if argent_joueur == 2*dette and dette != 0:
        argent_joueur = argent_joueur-dette
        dette = 0
        argent['text'] = f'Crédits: {str(argent_joueur)}'
        if debug == 1:
            print('dette remboursée')
        if dette == 0:
            dette_label['text'] = 'Vos dettes sont remboursées'
            dette_label['fg'] = 'red'
            dette_label.after(5000, lambda: dette_label.grid_forget())


# Interface pour permettre au joueur de comprendre les boutons et graphismes


# Fonction pour afficher un tuto sur comment jouer


def tutoriel(event):

    i = 0

    def retour():
        # Fonction pour faire un retour en arrière 
        global i
        image = ['./Images/image_debut.png', './Images/image_mise.png',
                 './Images/image_action.png',
                 './Images/image_résultat.png',
                 './Images/image_emprunt.png']
        if event.widget == bouton_retour and i != 0:
            while i != len(image):
                image_tuto['test'] = image[i-1]
        else:
            i += 1
##à compléter et corriger
    def passer():
        # Fonction pour passer d'une image à une autre
        global i
        if event.widget == bouton_pass and i == 0 : 
            i += 1
            image_tuto = Image.open('./Images/image_mise.png')
            resize_image = image_tuto.resize((500,500))
            image_tuto_dic['text'] = ImageTk.PhotoImage(resize_image, master=interface)
            canvas_im.create_image(10, 10, image=image_tuto_dic['text'], anchor='center')
        if event.widget == bouton_pass and i == 1 : 
            i += 1
            image_tuto = Image.open('./Images/image_action.png')
            resize_image = image_tuto.resize((500,500))
            image_tuto_dic['text'] = ImageTk.PhotoImage(resize_image, master=interface)
            canvas_im.create_image(10, 10, image=image_tuto_dic['text'], anchor='center')
        if event.widget == bouton_pass and i == 2 : 
            i += 1
            image_tuto = Image.open('./Images/image_résultat.png')
            resize_image = image_tuto.resize((500,500))
            image_tuto_dic['text'] = ImageTk.PhotoImage(resize_image, master=interface)
            canvas_im.create_image(10, 10, image=image_tuto_dic['text'], anchor='center')
        if event.widget == bouton_pass and i == 3 : 
            i += 1
            image_tuto = Image.open('./Images/image_emprunt.png')
            resize_image = image_tuto.resize((500,500))
            image_tuto_dic['text'] = ImageTk.PhotoImage(resize_image, master=interface)
            canvas_im.create_image(10, 10, image=image_tuto_dic['text'], anchor='center')
        if event.widget == bouton_pass  and i == 4:
            bouton_pass['command']= interface.pack_forget()


    if event.widget == bouton_tutoriel:
        #affiche de la fenêtre liée au tutoriel
        interface = tkinter.Frame()
        interface.configure == root.configure
        #bouton pour passer à l'image suivante
        bouton_pass = tkinter.Button(interface, text='suivant',
                                     bg='white', fg='black')
        bouton_pass.pack(side='right', anchor='s')
        bouton_pass.bind('<Button-1>', passer)
        #bouton pour revenir à l'image précédente
        bouton_retour = tkinter.Button(interface, text='retour',
                                       bg='white', fg='black')
        bouton_retour.pack(side='left', anchor='s')
        bouton_retour.bind('<Button-1>', retour)

        canvas_im = tkinter.Canvas(interface)
        canvas_im.pack()
        image_tuto = Image.open('./Images/image_debut.png')
        resize_image = image_tuto.resize((500,500))
        image_tuto_dic['text'] = ImageTk.PhotoImage(resize_image, master=interface)
        canvas_im.create_image(10, 10, image=image_tuto_dic['text'], anchor='center')
        root.pack_forget()
        interface.pack(expand=True, fill=tkinter.BOTH)


def dir_regles(event):
    """ fonction associée au bouton comment joueur
    permettant au joueur de connaître les règle du jeu"""
    if event.widget == bouton_rdj:
        règle = tkinter.Frame()
        règle.configure(bg='white')
        titre = tkinter.Label(règle, text='REGLE DU BLACKJACK 21\n',
                              bg='white', fg='black', font=('helvetica', 23))
        titre.pack(side='top')
        jeu = tkinter.Label(règle, text='Le BlackJack se joue avec 312 ' +
                            'cartes. 6 jeux de 52 cartes.\n',
                            bg='white', fg='gray13', font=('helvetica', 15))
        jeu.pack(side='top')

        valeurs_cartes = tkinter.Label(règle, text='Valeur des cartes',
                                       bg='white', fg='black',
                                       font=('helvetica', 17))
        valeurs_cartes.pack(side='top')

        points_cartes = tkinter.Label(règle, text='de 2 à 9 : valeur '
                                      'nominale de la carte\n de 10 au roi' +
                                      '(surnommées « bûche ») : 10 points' +
                                      '\n as : 1 ou 11 points (au choix ' +
                                      'du joueur)\n Le but du joueur ' +
                                      'est d’obtenir exactement 21 points.\n',
                                      bg='white', fg='gray13',
                                      font=('helvetica', 15))
        points_cartes.pack(side='top')

        deroulement_partie = tkinter.Label(règle, text='Déroulement d’une ' +
                                           'partie', bg='white', fg='black',
                                           font=('helvetica', 17))
        deroulement_partie.pack(side='top')

        deroulement_partie_texte = tkinter.Label(règle, text='Au début du ' +
                                                 'jeu, 2 cartes sont ' +
                                                 'distribuées au Player.\n' +
                                                 'A chaque tour, le Player ' +
                                                 'peut prendre des actions.' +
                                                 '\n Le Dealer pioche ' +
                                                 'jusqu’à atteindre 17 '
                                                 'points minimum.\n',
                                                 bg='white', fg='grey13',
                                                 font=('helvetica', 15))
        deroulement_partie_texte.pack(side='top')

        gagnant_texte = tkinter.Label(règle, text='Comment gagner ?',
                                      bg='white', fg='black',
                                      font=('helvetica', 17))
        gagnant_texte.pack(side='top')

        gagnanttexte = tkinter.Label(règle, text='Si le Dealer possède une ' +
                                     'main supérieure à 21, vous gagnez la ' +
                                     ' partie en cours. Vous gagnez 150% ' +
                                     'de votre mise.\n Si le Dealer a une ' +
                                     'main comprise entre 17 et 21 points, ' +
                                     'et que vous avez un score supérieur ' +
                                     'alors vous gagnez.\n Si vous avez ' +
                                     'une main supérieure à 21 points, ' +
                                     'vous perdez votre mise.\n En cas ' +
                                     'd’égalité, vous serez remboursé.\n',
                                     bg='white', fg='gray13',
                                     font=('helvetica', 15))

        gagnanttexte.pack(side='top')

        action = tkinter.Label(règle, text='Actions', bg='white',
                               fg='black', font=('helvetica', 17))
        action.pack(side='top')
        action_texte = tkinter.Label(règle, text='Hit : vous piochez autant ' +
                                     'de cartes souhaitées pour se ' +
                                     'rapprocher de 21\n Stand : le Player ' +
                                     'conserve ses cartes, il annonce s’il ' +
                                     'reste ou s’il s’arrête\n Double Down ' +
                                     ': le Player double sa mise, mais ' +
                                     'ne peut recevoir qu’une seule carte\n' +
                                     'Surrender : le Player abandonne et ' +
                                     'perd la moitié de sa mise',
                                     bg='white', fg='gray13',
                                     font=('helvetica', 15))
        action_texte.pack(side='top')

        def revenir(event):
            """fonction pour revenir au jeu et de
            quitter la fenêtre lorsque
            le bouton est appuyée"""
            if event.widget == bouton_revenir:
                règle.pack_forget()
                root.pack(fill=tkinter.BOTH, expand=True)
        bouton_revenir = tkinter.Button(règle, text='Revenir au jeu', fg='red')
        bouton_revenir.pack()
        bouton_revenir.bind('<Button-1>', revenir)
    root.pack_forget()
    règle.pack(fill=tkinter.BOTH, expand=True)


# Fenêtre accueil


window = tkinter.Tk()
window.title('Menu BlackJack 21')
#window.geometry('750x600')
window.state("zoomed")
window.resizable(width=False, height=False)

accueil = tkinter.Frame()
accueil.configure(bg='red')

# Variables relatives aux graphismes du jeu

# Graphismes

# Configuration de l'écran d'acceuil"""
titre_jeu = tkinter.Label(accueil, text='BLACK JACK', bg='red', fg='gold',
                          font=('helvetica', 70))
titre_jeu.pack()

play = tkinter.Canvas(accueil, width=200, height=200, bg='red',
                      highlightthickness=0)
play.create_oval(34, 40, 180, 190, width=3, outline='mint cream',
                 fill='mint cream')
play.create_text(102, 115, text='Play', font=('elephant', 35), fill='black')

play.pack(anchor='center')

play.bind('<Button-1>', debut)

image_jeton_play = Image.open("./Images/image0.png")
resize_image = image_jeton_play.resize((240, 200))
img = ImageTk.PhotoImage(resize_image)
play.create_image(100, 100, image=img, anchor='center')


#affichage image de la pile de jeton
pile = tkinter.Canvas(accueil, width=200, height=200, bg='red',
                      highlightthickness=0)
pile.pack(anchor='center')
image_jeton_pile = Image.open("./Images/jeton_pile.png")
resize_image0 = image_jeton_pile.resize((240, 200))
img0 = ImageTk.PhotoImage(resize_image0)
pile.create_image(100, 100, image=img0, anchor='center')

"""
#affichage image du jeton bleu
bleu = tkinter.Canvas(accueil, width=100, height=100, bg='red',
                      highlightthickness=0)
bleu.pack(side='top', anchor='ne')
image_jeton_bleu = Image.open("./Images/image_jeton_bleu.png")
resize_image1 = image_jeton_bleu.resize((220, 200))
img1 = ImageTk.PhotoImage(resize_image1)
bleu.create_image(100, 100, image=img1, anchor='center')

#affichage image du jeton rouge
rouge = tkinter.Canvas(accueil, width=100, height=100, bg='red',
                      highlightthickness=0)
rouge.pack(side='top', anchor='nw')
image_jeton_rouge = Image.open("./Images/image_jeton_rouge.png")
resize_image2 = image_jeton_rouge.resize((220, 200))
img2 = ImageTk.PhotoImage(resize_image2)
rouge.create_image(100, 100, image=img2, anchor='center')
 
#affichage image du jeton vert
vert = tkinter.Canvas(accueil, width=100, height=100, bg='red',
                      highlightthickness=0)
rouge.pack(side='bottom', anchor='nw')
image_jeton_vert = Image.open("./Images/image_jeton_vert.png")
resize_image3 = image_jeton_vert.resize((220, 200))
img3 = ImageTk.PhotoImage(resize_image3)
vert.create_image(100, 100, image=img3, anchor='center')

#affichage image du jeton noir
noir = tkinter.Canvas(accueil, width=100, height=100, bg='red',
                      highlightthickness=0)
noir.pack(side='bottom', anchor='nw')
image_jeton_vert = Image.open("./Images/image_jeton_noir.png")
resize_image4 = image_jeton_vert.resize((220, 200))
img4 = ImageTk.PhotoImage(resize_image4)
noir.create_image(100, 100, image=img4, anchor='center')

"""
# Entrée permettant au joueur de choisir son pseudo ainsi que le nombre de
# crédit souhaité
username = tkinter.Label(accueil, text="Username:",
                         font=('helvetica', 10), fg='black')
username.pack()

entree_username = tkinter.Entry(accueil)
entree_username.pack(anchor='center')

credit = tkinter.Label(accueil, text="Crédit:", font=('helvetica', 10),
                       fg='black')
credit.pack()

entree_credit = tkinter.Entry(accueil)
entree_credit.pack()


# Graphisme fenêtre acceuil


cartes1 = tkinter.Canvas(accueil, width=180, height=260, bg='green')
cartes2 = tkinter.Canvas(accueil, width=180, height=260, bg='green')
cartes1.pack(side='left', anchor='n')
cartes2.pack(side='left', anchor='n')

cartes3 = tkinter.Canvas(accueil, width=180, height=260, bg='green')
cartes4 = tkinter.Canvas(accueil, width=180, height=260, bg='green')
cartes3.pack(side='right', anchor='n')
cartes4.pack(side='right', anchor='n')

erreur_argent = tkinter.Label(
    accueil, text='Erreur\n Veuillez entrer un nombre entier\n' +
    'positif supérieur à 0 et inférieur à 9 999 999 999 \n' +
    'pour les crédits', width=35,
    justify='center')

erreur_nom = tkinter.Label(accueil, text='Erreur\nVeuillez ' +
                           'entrer un nom de 15 caractères\nou ' +
                           'moins', width=35)

#code à afficher pour les jetons

accueil.pack(fill=tkinter.BOTH, expand=True)



# Fenêtre root
root = tkinter.Frame()
"""root.state('zoomed')"""
root.configure(bg="dark green")

erreur = tkinter.Label(root, text='', font=('helvetica', 10),
                        fg='black')

cartes = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
dos_carte(cartes, 'cartes')
cartes.grid(column=2, row=3)

# Interface graphique

# Ensemble des widgets utilisés dans la fenêtre root

# Bouton pour accéder aux règles du jeu
bouton_rdj = tkinter.Button(root, text='règle du jeu',
                            width=13, height=2, fg='navy',
                            font=('helvetica', 10))
bouton_rdj.grid(column=0, row=0)
bouton_rdj.bind('<Button-1>', dir_regles)

# Bouton pour quitter la partie
bouton_quitter = tkinter.Button(root, text='Quitter la partie', fg='red')
bouton_quitter.grid(column=2, row=11)
bouton_quitter.bind('<Button-1>', quitter)

# Mélanger le jeu de carte
bouton_melanger = tkinter.Button(root,
                                    text='Mélanger', fg='blue',
                                    command=random.shuffle(paquet))
bouton_melanger.grid(column=2, row=3)
bouton_melanger.bind('<Button-1>', ordre_boutons2)

# Bouton pour distribuer le jeu de carte
bouton_donne_initiale = tkinter.Button(root,
                                        text='Donne initiale', fg="blue")
bouton_donne_initiale.bind('<Button-1>', ordre_boutons3)

# Bouton qui relance la partie sans quitter le jeu
bouton_rejouer = tkinter.Button(root,
                                text='Rejouer', fg="blue", command=rejouer)

# Bouton qui permet de piocher
bouton_hit = tkinter.Button(root, bg='white', text='Hit')
bouton_hit.bind('<Button-1>', lambda e: hit(main_joueur, 'main_joueur'))

# Bouton qui permet de 'double down'
bouton_double_down = tkinter.Button(root, bg='white', text='Double Down')
bouton_double_down.bind('<Button-1>', lambda e: doubble_down(
    main_joueur))

# Bouton qui permet de 'stand'
stand_bouton = tkinter.Button(root, bg='salmon', text='Stand')
stand_bouton.bind(
    "<Button-1>", lambda e: stand())

# Bouton qui permet de 'surrender'
bouton_surrender = tkinter.Button(root, bg='red', text='Surrender')
bouton_surrender.bind('<Button-1>', lambda e: surrender())

# Bouton qui 'split'
bouton_split = tkinter.Button(root, text='Split', command=splitter)

bouton_joueur = [bouton_hit, stand_bouton, bouton_surrender,
                    bouton_double_down]

texte_assurance = tkinter.Label(root, text='')

# Widgets pour l'assurance
bouton_oui_assurance = tkinter.Button(root, text='Oui')
bouton_non_assurance = tkinter.Button(root, text='Non')

bouton_oui_assurance.bind(
    '<Button-1>', lambda e: reponse_assurance(reponse='oui'))
bouton_non_assurance.bind(
    '<Button-1>', lambda e: reponse_assurance(reponse='non'))

assurance_valeur = tkinter.Label(root, text='')

# Widgets associés à l'emprunt + dettes
valid = tkinter.Button(root, text='valider l\'emprunt',
                        bg='dark green', fg='black')
valid.bind('<Button-1>', validd)
banque = tkinter.Label(root, text='Vous êtes à cours de crédit',
                        font=('helvetica', 15), bg='dark green',
                        fg='red')
emprunt = tkinter.Button(root, text='Emprunt')
emprunt.bind('<Button-1>', emprunter)
term = tkinter.Button(root, text='Terminer')
term.bind('<Button-1>', quitter)

eprnt = tkinter.Label(root, text='Combien souhaitez-vous ' +
                        'emprunter ?', fg='black',
                        bg='dark green')
my_entry3 = tkinter.Entry(root)

entry_label = tkinter.Label(root, text='', bg='dark green', fg='red')

canvas_emprunt = [my_entry3, valid, banque, eprnt, entry_label]

dette_label = tkinter.Label(root, text='', bg='dark green', fg='red',
                            font=('helvetica', 10))

# Bouton qui permet l'accès au tutoriel
bouton_tutoriel = tkinter.Button(root, text='Comment jouer ?',
                                    bg='green', fg='white',
                                    width=13, height=2,
                                    font=('helvetica', 10))
bouton_tutoriel.grid(column=1, row=0)
bouton_tutoriel.bind('<Button-1>', tutoriel)

# Mise du jeu """
mise_totale = 0
mise_valeur = {'jeton_vert': 1, 'jeton_rouge': 10, 'jeton_bleu': 25,
                'jeton_blanc': 50, 'jeton_noir': 100,
                'tapis': 'argent_joueur'}

# Widgets associés à la mise du joueur

argent = tkinter.Label(root, text='Crédits: '+str(argent_joueur),
                        bg='dark green', fg='white')
argent.grid(column=0, row=8)

mise_texte = tkinter.Label(
    root, text='Mise totale: ', bg='dark green', fg='white')

miser = tkinter.Label(root, text="Cliquez pour miser:",
                        bg='dark green', fg='white')

# Position des widgets jetons pour la mise

jeton_tapis = tkinter.Canvas(root, bg='dark green', width=60, height=45,
                                relief='raised', borderwidth=0,
                                highlightthickness=0)
jeton_tapis.create_text(26, 21, text='All in',
                        font=('helvetica', 12), fill='white')
jeton_tapis.create_oval(4, 4, 50, 40, width=3,
                        outline='white')

jeton_blanc = tkinter.Canvas(root, bg='dark green', width=30, height=30,
                                relief='raised', borderwidth=0,
                                highlightthickness=0)
jeton_blanc.create_oval(1, 1, 25, 25, width=3,
                        outline='chartreuse4', fill='green4')

jeton_blanc.create_text(
    13, 13, text='50', font=('helvetica', 8), fill='white')

jeton_bleu = tkinter.Canvas(root, bg='dark green', width=30, height=30,
                            relief='raised', borderwidth=0,
                            highlightthickness=0)
jeton_bleu.create_oval(1, 1, 25, 25, width=3, outline='blue4', fill='navy')
jeton_bleu.create_text(13, 13, text='25', font=(
    'helvetica', 8), fill='white')

jeton_rouge = tkinter.Canvas(root, bg='dark green', width=30, height=30,
                                relief='raised', borderwidth=0,
                                highlightthickness=0)
jeton_rouge.create_oval(1, 1, 25, 25, width=3,
                        outline='brown4', fill='red')
jeton_rouge.create_text(
    13, 13, text='10', font=('helvetica', 8), fill='white')

jeton_noir = tkinter.Canvas(root, bg='dark green', width=30, height=30,
                            relief='raised', borderwidth=0,
                            highlightthickness=0)
jeton_noir.create_oval(1, 1, 25, 25, width=3,
                        outline='gray19', fill='gray14')
jeton_noir.create_text(13, 13, text='100', font=(
    'helvetica', 8), fill='white')

jeton_vert = tkinter.Canvas(root, bg='dark green', width=30, height=30,
                            relief='raised', borderwidth=0,
                            highlightthickness=0)
jeton_vert.create_oval(1, 1, 25, 25, width=3, outline='light grey',
                        fill='mint cream')
jeton_vert.create_text(13, 13, text='1', font=(
    'helvetica', 8), fill='black')

# Commande d'incrémentation de mises

jeton_vert.bind('<Button-1>', lambda e: mise(1))

jeton_rouge.bind('<Button-1>', lambda e: mise(10))

jeton_bleu.bind('<Button-1>', lambda e: mise(25))

jeton_blanc.bind('<Button-1>', lambda e: mise(50))

jeton_noir.bind('<Button-1>', lambda e: mise(100))

jeton_tapis.bind('<Button-1>', lambda e: mise(argent_joueur))

jeton_et_mise = [jeton_vert, jeton_blanc, jeton_bleu, jeton_rouge,
                    jeton_noir, jeton_tapis, miser]

# Texte qui définit le côté du croupier
labelc = tkinter.Label(root, text="Dealer ", font=(
    "helvetica", "15"), bg="dark green", fg="black")
labelc.grid(column=0, row=1)

# Texte qui définit le côté du joueur
labelj = tkinter.Label(root, text=nom_joueur, font=("helvetica", "15"),
                        bg="dark green", fg="black")
labelj.grid(column=0, row=7)

# Canvas pour l'affichage des cartes dans l'interface graphique
# (techniquement un joueur peut avoir au maximum 21 cartes car il y a 24
# As valant 1 points dans le jeu et donc si le joueur ne fait que piohcer
# des As, il aura au maximum 21 cartes)
cj = {}
for i in range(22):
    cj[f"cj{i}"] = tkinter.Canvas(root, width=66, height=100,
                                    bg='#55AA55')

cc = {}
for i in range(22):
    cc[f"cc{i}"] = tkinter.Canvas(root, width=66, height=100,
                                    bg='#55AA55')

cja = {}
for i in range(22):
    cja[f"cj{i}a"] = tkinter.Canvas(root, width=66, height=100,
                                    bg='#55AA55')

# Interface emplacement des cartes 1 et 2 du joueur
cj['cj1'].grid(column=1, row=7)
cj['cj2'].grid(column=3, row=7)

# Interface emplacement des cartes 1 et 2 du croupier
cc['cc1'].grid(column=1, row=1)
cc['cc2'].grid(column=3, row=1)

numero_main = tkinter.Label(root, text='')

# Label pour afficher l'action du joueur
stand_label = tkinter.Label(root, bg='dark green', fg='black',
                            text="<<Je m'arrête>>",
                            font=("helvetica", "15"))
resultat_final = tkinter.Label(
    root, text='annonce', bg='dark green', fg='red')
resultat_label = tkinter.Label(
    root, text='', bg='dark green', fg='yellow')

# Label qui affiche le nombre de cartes restantes
nb_carte_paquet = tkinter.Label(
    root, text='Nombre de cartes restantes dans le paquet:' +
    f' {str(len(paquet))} \nNombre de cartes restantes dans la' +
    f' défausse: {str(len(defausse))}', bg='dark green')
nb_carte_paquet.grid(column=10, row=0)


window.mainloop()