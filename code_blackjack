#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = "Mathilde, Maïlys, Joseph"
__copyright__ = "Copyright 2023, Projet Blacjack"
__credits__ = ["Mathilde", "Maïlys", "Joseph"]
__license__ = "GPL"
__version__ = "0.1.1"
__maintainer__ = "Joseph ARIAS"
__email__ = "joseph.arias@ens.uvsq.fr"
__status__ = "Developement"

import random
import tkinter
from PIL import Image, ImageTk

# listes et variables

# p = pique, co = coeur, t = trèfle, ca = carreau
dic_valeur_cartes = {'2p': 2, '3p': 3, '4p': 4, '5p': 5, '6p': 6, '7p': 7,
                     '8p': 8, '9p': 9, '10p': 10, 'Vp': 10, 'Dp': 10,
                     'Rp': 10, 'Ap': 11,
                     '2co': 2, '3co': 3, '4co': 4, '5co': 5, '6co': 6,
                     '7co': 7, '8co': 8, '9co': 9, '10co': 10, 'Vco': 10,
                     'Dco': 10, 'Rco': 10, 'Aco': 11,
                     '2t': 2, '3t': 3, '4t': 4, '5t': 5, '6t': 6, '7t': 7,
                     '8t': 8, '9t': 9, '10t': 10, 'Vt': 10, 'Dt': 10,
                     'Rt': 10, 'At': 11,
                     '2ca': 2, '3ca': 3, '4ca': 4, '5ca': 5, '6ca': 6,
                     ' 7ca': 7, '8ca': 8, '9ca': 9, '10ca': 10, 'Vca': 10,
                     'Dca': 10, 'Rca': 10, 'Aca': 11}


paquet = list(dic_valeur_cartes.keys())*6
defausse = []
# La coupe correspond au nombre de carte qui vont être jouées avant que le
# croupier ne remélange le jeu. Dans la réalité, le croupier place une carte
# rouge dans le paquet de carte à un endroit aléatoire (il doit cependnat y
# avoir au moin sun jeu soit 52 cartes avant et apès la carte rouge). Dans le
# reste des commentaires du code, on parlera donc de carte rouge
coupe = random.randint(52, len(paquet)-52)

# Différentes main pour acceuillir les cartes piochées
main_joueur = []
main_croupier = []
# Main utilisée lorsque le joueur fait un split
main_joueur_split = []

# Variables permettant au programme de savoir si le joueur a effectué
# certaines actions. Lorsque la variable vaut 0, l'action n'a pas été effectuée

# Split peut valoir 0, 1 ou 2. Si plit == 0, alors le joueur n'a pas fait de
# split. Si split == 1, alors le joueur a fait un split et joue sa première
# main. Si split == 2, le joueur joue sa deuxième main.
split = 0
# Blacjack peut valoir 0 ou 1 et permet de savoir si le joueur a fait un
# blackjack
blackjack = 0
# Assurance prise peut valoir 0 ou 1 et permet de savoir si le joueur a payé
# une assurance lorsque le croupier a révélé que sa première carte était un As
assurance_prise = 0
# Assurance gagnante peut valoir 0 ou 1 permet de savoir si l'assurance prise
# par le joueur est gagnate ou non, c'est à dire si le croupier avait
# effectivement un blackjack ou pas
assurance_gagnante = 0

# Variables qui dépendent du joueur et/ou peuvent évoluer au cours de la partie

argent_joueur = 0
prix_assurance = 0
dette = 0
nom_joueur = ''
nombre_partie = 0
nombre_emprunt = 0

# Dictionnaires permettant de contourner le garbage collector

images = dict()
image_dos = dict()

# Si debug == 1, alors les print sont effectifs. Si debug == 0, aucun print
# n'apparait

debug = 1


if debug == 1:
    print(coupe)

"""Fonctions"""


def creer_image(carte, position_carte, texte):
    """Créer l'image d'une carte.

    Cette fonction sert à créer l'image de la carte sur l'interface graphique.

    Parametres
    ----------
    carte : str
        Le nom de la carte.
    position_carte : canvas
        Le canvas sur lequel l'image de la carte va s'afficher.
    texte : str
        Texte qui va créer une clé dans le dictionnaire dic_valeur_cartes pour
        eviter le garbage collector
    """
    image_carte = Image.open("./Images/cartes.png")
    if debug == 1:
        print('ok', carte)
    # A, B, C, D ont été mesurées au préalable et correspond à l'écart entre
    # chaque carte sur l'image cartes.png
    A = 30
    B = 30
    C = 390
    D = 570
    if 'co' in carte:
        B += 570
        D += 570
    if 'ca' in carte:
        B += 570*2
        D += 570*2
    if 't' in carte:
        B += 570*3
        D += 570*3
    for i in range(2, 11):
        if str(i) in carte:
            A += 390 * (i-1)
            C += 390 * (i-1)
    if 'V' in carte:
        A += 390*10
        C += 390*10
    if 'D' in carte:
        A += 390*11
        C += 390*11
    if 'R' in carte:
        A += 390*12
        C += 390*12
    if debug == 1:
        print(A, B, C, D)
    crop_rectangle = (A, B, C, D)
    cropped_im = image_carte.crop(crop_rectangle)
    image_fin = cropped_im.resize((66, 100))
    # L'ajout de "texte" au doctionnaire image permet d'éviter le garbage
    # collector
    images[texte] = ImageTk.PhotoImage(image_fin)
    position_carte.create_image(2, 2, anchor='nw', image=images[texte])


def dos_carte(position, texte):
    """Créer l'image du dos des cartes.

    Cette fonction sert à créer l'image de du dos des carte sur l'interface
    graphique.

    Parametres
    ----------.
    position : canvas
        Le canvas sur lequel l'image de la carte va s'afficher.
    texte : str
        Texte qui va créer une clé dans le dictionnaire dic_valeur_cartes pour
        eviter le garbage collector
    """
    image_carte = Image.open("./Images/dos_cartes3.jpg")
    image_fin = image_carte.resize((66, 100))
    images[texte] = ImageTk.PhotoImage(image_fin)
    position.create_image(2, 2, anchor='nw', image=images[texte])


def debut(event):
    """Débuter la partie.

    Cette fonction sert à afficher la fenêtre correspondant au jeu lorsque
    l'on appuie sur le bouton play.

    Parametres
    ----------.
    event
    """
    global nom_joueur
    global argent_joueur
    if event.widget == play:
        nom_joueur = my_entry.get()
        argent_joueur = my_entry2.get()
        if not argent_joueur.isdigit() or argent_joueur <= 0:
            erreur_argent = tkinter.Label(
                accueil, text='Erreur\n Veuillez entrer un nombre entier ' +
                'positif supérieur à 0 pour les crédits')
            erreur_argent.pack()
        if len(nom_joueur) > 15:
            erreur_nom = tkinter.Label(accueil, text='Erreur\nVeuillez ' +
                                       'entrer un nom de 15 caractères ou' +
                                       'moins')
            erreur_nom.pack()
        if nom_joueur == '':
            nom_joueur = 'Player'
        if argent_joueur != '':
            argent_joueur = int(argent_joueur)
        if argent_joueur != '' and nom_joueur != '':
            accueil.destroy()


def donne_initiale():
    """Donne initiale des cartes aux joueurs et au croupier.

    Cette fonction sert à distribuer deux cartes à tous les joueurs et au
    croupier lorsque la manche débute
    """
    global paquet
    global main_joueur
    global main_croupier
    global blackjack
    global assurance_prise
    global mise_totale
    global nombre_partie
    disparition_mise()
    bouton_donne_initiale.grid_forget()
    nb_carte_piochee = 0
    while nb_carte_piochee < 2:
        main_joueur.append(paquet[0])
        del paquet[0]
        nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le ' +\
            f'paquet: {str(len(paquet))} \nNombre de cartes restantes ' +\
            f'dans la défausse: {str(len(defausse))}'
        main_croupier.append(paquet[0])
        del paquet[0]
        nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le ' +\
            f'paquet: {str(len(paquet))} \nNombre de cartes restantes ' +\
            f'dans la défausse: {str(len(defausse))}'
        nb_carte_piochee += 1
        nombre_partie += 1
    creer_image(main_joueur[0], cj1, 'cj1')
    # Les différents root.after du programme servent à ne faire apparaitre les
    # cartes qu'après 0,5 seconde pour rendre le jeu plus naturel. Ils n'ont
    # donc qu'un but purement décoratif
    root.after(500, root.update())
    creer_image(main_croupier[0], cc1, 'cc1')
    root.after(500, root.update())
    creer_image(main_joueur[1], cj2, 'cj2')
    root.after(500, root.update())
    dos_carte(cc2, 'cc2')
    if 'A' in main_croupier[0]:
        if debug == 1:
            print('As détecté')
        prix_assurance = mise_totale // 2
        if argent_joueur >= prix_assurance:
            texte_assurance['text'] = 'Le Dealer vient de tirer un ' + \
                f'As. Voulez vous payer une assurance ({prix_assurance})?'
            texte_assurance.grid(column=2, row=3)
            bouton_oui_assurance.grid(column=2, row=4)
            bouton_non_assurance.grid(column=2, row=5)
            root.update()
        else:
            if score(main_joueur) == 21:
                blackjack = 1
                croupier()
            else:
                bouton_melanger.grid_forget()
                apparition_bouton_joueur()
    else:
        if score(main_joueur) == 21:
            blackjack = 1
            croupier()
        else:
            bouton_melanger.grid_forget()
            apparition_bouton_joueur()
    if debug == 1:
        print('main joueur', main_joueur, '\n main croupier', main_croupier)


def reponse_assurance(reponse=0):
    """Réaction suite à la réponse du joueur concernant l'assurance.

    Cette fonction sert à déterminer si le joueur prend ou non l'assurance

    Parametres
    ----------.
    reponse : str
        Permet de déterminer si le joueur prend l'assurance ou non
    """
    global argent_joueur
    global assurance_prise
    global bouton_non_assurance
    global bouton_oui_assurance
    global blackjack
    global mise_totale
    prix_assurance = mise_totale // 2
    if reponse == 'oui':
        argent_joueur -= prix_assurance
        assurance_prise = 1
        assurance_valeur['text'] = f'Assurance: {str(prix_assurance)}'
        assurance_valeur.grid(column=0, row=10)
    bouton_non_assurance.grid_forget()
    bouton_oui_assurance.grid_forget()
    texte_assurance.grid_forget()
    argent['text'] = f'Crédits: {str(argent_joueur)}'
    if score(main_joueur) == 21:
        blackjack = 1
        croupier()
    if blackjack == 0:
        bouton_melanger.grid_forget()
        apparition_bouton_joueur()


def hit(main, pointeur):
    """Hit.

    Cette fonction sert à faire piocher une carte lorsque le joueur ou le
    croupier "hit".

    Parametres
    ----------.
    main : list
        Correspond à la main qui va piocher la carte
    pointeur : str
        Permet de savoir si c'est le croupier qui pioche ou un joueur
    """
    global main_joueur
    global main_croupier
    global paquet
    if split == 2 and main != main_croupier:
        # cja correspond à la liste de canvas utilisée pour afficher les
        # cartes de la deucime main du joueur en cas de split
        carte = cja
        main = main_joueur_split
        # a est une variable permettant d'ajuster la position de les cartes de
        # la deucième main du joueur sur l'interface graphique en cas de split
        a = 1
    else:
        carte = cj
        a = 0
    if pointeur == 'main_joueur':
        bouton_double_down.grid_forget()
        bouton_split.grid_forget()
        bouton_surrender.grid_forget()
        main.append(paquet[0])
        del paquet[0]
        nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le ' +\
            f'paquet: {str(len(paquet))} \nNombre de cartes restantes ' +\
            f'dans la défausse: {str(len(defausse))}'
        for i in range(3, 14):
            if len(main) == i:
                creer_image(main[i-1], carte[i-1], f'{carte[i]}')
                carte[i-1].grid(column=4+i, row=7+a)
        # on vérifie que le joueur n'ai pas de Blackjack
        test_score(main)
    if pointeur == 'main_croupier':
        if debug == 1:
            print(len(main))
        main.append(paquet[0])
        del paquet[0]
        nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le ' +\
            f'paquet: {str(len(paquet))} \nNombre de cartes restantes ' +\
            f'dans la défausse: {str(len(defausse))}'
        for i in range(3, 14):
            if len(main) == i:
                creer_image(main[i-1], cc[i-1], f'cc{i}')
                root.after(500, root.update())
                cc[i-1].grid(column=4+i, row=1)
    root.update()


def test_score(main):
    """Tester le score d'une main.

    Cette fonction sert à vérifier qu'une main d'un joueur ne vale pas ou ne
    dépasse pas 21 points. Si c'est le cas, aucune action supplémentaire du
    joueur ne peut avoir lieu sur la main en question

    Parametres
    ----------.
    main : list
        Correspond à la main dont le socre est testé
    """
    global split
    if score(main) >= 21:
        if split == 1:
            if debug == 1:
                print('apparition main 2 dans test score')
            numero_main['text'] = 'Main 2'
            split = 2
        else:
            croupier()


def disparition_bouton_joueur():
    """Réaction suite à la réponse du joueur concernant l'assurance.

    Cette fonction sert à faire disparaitre de l'interface graphique les
    boutons qu'utilise le joueur pour déterminer quelle action il effectue vis
    à vis de sa main
    """
    global bouton_hit
    if debug == 1:
        print("bouton test", bouton_hit.grid_info())
    for i in range(len(bouton_joueur)):
        bouton_joueur[i].grid_forget()
    bouton_split.grid_forget()


def fin_manche():
    """Ramassage des cartes en fin de manche.

    Cette fonction sert à enlever les cartes des différentes main et les
    placer dans la défausse
    """
    global main_croupier
    global main_joueur
    global defausse
    disparition_bouton_joueur()
    while len(main_joueur) != 0:
        defausse.append(main_joueur[0])
        del main_joueur[0]
    while len(main_croupier) != 0:
        defausse.append(main_croupier[0])
        del main_croupier[0]
    if debug == 1:
        print(len(paquet), paquet)
        print('mains croupier ', main_croupier, 'main joueur', main_joueur)
    bouton_rejouer.grid(column=2, row=3)


def score(main):
    """Score d'une main.

    Cette fonction sert à déterminer quel est le score d'une main

    Parametres
    ----------.
    main : list
        Correspond à la main dont le score est évalué
    """
    points = 0
    # Pour chauque carte dans la main, on évalue combien de point elle vaut en
    # se référant au dictionnaire de valeur des cartes
    for element in main:
        points += dic_valeur_cartes.get(element)
        if debug == 1:
            print(points, dic_valeur_cartes.get(element), element)
    boucle = 0
    while points > 21:
        # condition pour éviter que la boucle ne tourne à l'infini
        if boucle > len(main)-1:
            break
        # Si la main vaut plus que 21 points et que la main contient un As,
        # alors l'As vaut 1 au lieu de 11 ce qui équivaut à enlever 11 points
        # à la main puique l'As a déjà était comptabilisé et évalué à 11 points
        # plus haut dans la fonction. Pour être sûr que chaque As ne soit
        # compté qu'une seule fois, on vérifie si chaque carte est un As ou pas
        if 'A' in main[boucle]:
            points -= 10
        boucle += 1
    if debug == 1:
        print('point final', points)
    return points


def croupier():
    """Action du croupier

    Cette fonction sert à faire jouer le croupier: il pioche des carte
    jusqu'à avoir 17 points ou plus
    """
    global main_croupier
    creer_image(main_croupier[1], cc2, 'cc2')
    cc2.grid(column=3, row=1)
    root.update()
    points_croupier = score(main_croupier)
    while score(main_croupier) <= 16:
        if debug == 1:
            print(points_croupier, main_croupier)
        hit(main_croupier, 'main_croupier')
    if debug == 1:
        print('resultat dans croupier')
    resultat()


def stand():
    """Stand.

    Cette fonction permet au joueur de stand, c'est à dire d'arreter de
    piocher des cartes et garder sa main en l'état actuel
    """
    global split
    stand_label.grid(column=10, row=5)
    bouton_split.grid_forget()
    if debug == 1:
        print("je m'arrête", split)
    if split == 0 or split == 2:
        croupier()
        disparition_bouton_joueur()
    if split == 1:
        split = 2
        numero_main['text'] = 'Main 2'


def doubble_down(main):
    """Doubble down

    Cette fonction sert à réagir lorsque le joueur doubble down: il double sa
    mise, reçois une carte, puis sont tour s'arrête

    Parametres
    ----------.
    main : list
        Correspond à la main qui double down
    """
    global mise_totale
    global argent_joueur
    global split
    bouton_split.grid_forget()
    argent_joueur -= mise_totale
    mise_totale *= 2
    mise_texte['text'] = f"Mise totale: {str(mise_totale)}"
    argent['text'] = f'Crédits: {str(argent_joueur)}'
    hit(main, 'main_joueur')
    if debug == 1:
        print(main)
    if split == 1:
        split = 2
        numero_main['text'] = 'Main 2'
    else:
        croupier()


def surrender():
    """Surrender.

    Cette fonction permet au joueur de "surrender", il abandonne la manche
    avant de piocher une carte et récupère la moitié de sa mise.
    """
    global split
    bouton_split.grid_forget()
    if split == 1:
        split = 2
        numero_main['text'] = 'Main 2'
    else:
        resultat(action='surrender')


def resultat(action=0):
    """Résultat de la manche

    Cette fonction sert à donner le résulat de la manche

    Parametres
    ----------.
    action : str
        Permet de savoir si le joueur a surrender ou pas
    """
    global main_croupier
    global assurance_prise
    global assurance_gagnante
    global blackjack
    global split
    resultat_label['text'] = ''
    taille_main_croupier = len(main_croupier)
    # Les scores du croupier et du joueur sont assignés à des variables afin
    # de n'avoir à passer une seule fois par main dans la fonction score
    score_croupier = score(main_croupier)
    score_joueur = score(main_joueur)
    # Consequence est une variable permettant de savoir quel gain donner dans
    # la fonction calcul_gain
    consequence = 0
    boucle = 1
    if debug == 1:
        print('Entrée résultat')
    if split != 0:
        resultat_label['text'] = 'Main 1 \n'
        boucle = 2
    # La boucle permet de prendre en compte le résultat des deux main si le
    # joueur a split
    while boucle != 0:
        if debug == 1:
            print('boucle')
        # Split peut effectivement être égal à 1 dans cette fonction car il
        # est décrémenter à la fin de la boucle while afin de bien calculer le
        # résultat des deux mains du joueur
        if split == 1:
            score_joueur = score(main_joueur_split)
        # Si le joueur a un blackjack
        if blackjack == 1:
            if debug == 1:
                print('taille main croupier', taille_main_croupier,
                      main_croupier, score_croupier)
            # Si le croupier a également un blackjack
            if (score_croupier == 21) and (taille_main_croupier == 2):
                resultat_label['text'] += 'Vous et le Dealer avez un ' + \
                    'Blacjack: ex aequo'
                consequence = 'egalite'
            # Si le croupier n'a pas de Blacjack
            else:
                resultat_label['text'] += 'BLACKJACK: vous êtes le vainqueur'
                consequence = 'Blackjack'
        # Si le joueur a surrender
        elif action == 'surrender':
            resultat_label['text'] += 'Vous avez abandonné'
            consequence = 'ff'
        # Si le joueur a dépassé 21 points
        elif score_joueur > 21:
            resultat_label['text'] += 'Votre main vaut plus que 21, vous' + \
                ' avez perdu.'
        # Si le joueur a 21 points ou moins
        elif score_joueur <= 21:
            # Si le croupier a dépassé 21 points
            if score_croupier > 21:
                resultat_label['text'] += 'Le Dealer a dépassé 21: vous ' +\
                    'avez gagné !'
                consequence = 'win'
            # Si le croupier a 21 points ou moins
            elif score_croupier <= 21:
                # Si le croupier a fait un blackjack
                if (score_croupier == 21) and (taille_main_croupier == 2):
                    if debug == 1:
                        print('ok')
                    resultat_label['text'] += 'Le Dealer a fait un ' +\
                        ' BlackJack !\n'
                    # Si le joueur a lui aussi fait un blackjack, à noter
                    # qu'on ne peut pas faire de blackjack après un split
                    if score_joueur == 21 and len(main_joueur) == 2 \
                            and split == 0:
                        resultat_label['text'] += 'Vous avez également un ' +\
                            'BlackJack, votre mise est remboursée \n'
                        consequence = 'egalite'
                    # Si le joueur a pris l'assurance
                    if assurance_prise == 1:
                        resultat_label['text'] += 'Vous avez payé l\'' +\
                            'assurance, vous gagnez deux fois le montant ' +\
                            'de votre assurance \n'
                        assurance_gagnante = 1
                    # Si le joueur n'a pas de Blackjack
                    if score_joueur != 21 or len(main_joueur) != 2:
                        resultat_label['text'] += ' La main du Dealer ' +\
                            'est meilleure, vous avez perdu.e'
                # Si le joueur a un moins bon score que le croupier
                elif score_joueur < score_croupier:
                    resultat_label['text'] += 'Le Dealer a un meilleur ' + \
                        'score, vous avez perdu.'
                # Si le joueur a le même score que le croupier
                elif score_joueur == score_croupier:
                    resultat_label['text'] += 'Vous avez le même score ' + \
                        'que le Dealer: ex aequo'
                    consequence = 'egalite'
                # Si le joueur a un meilleur score que le croupier
                elif score_joueur > score_croupier:
                    resultat_label['text'] += 'Vous avez un meilleur ' +\
                        'score que le Dealer: vous avez gagné !'
                    consequence = 'win'
        if split == 0:
            annonce = f'Votre score: {str(score_joueur)} \n Score' + \
                f' du Dealer: {str(score_croupier)} \n'
        if split == 2:
            annonce = f'Score main 1: {str(score_joueur)}\n'
            resultat_label['text'] += '\n Main 2 \n'
        if split == 1:
            annonce += f'Score main 2: {str(score_joueur)}\n' + \
                f'Score du Dealer: {str(score_croupier)} \n'
        resultat_final['text'] = annonce
        resultat_final.grid(column=6+len(main_croupier), row=3)
        resultat_label.grid(column=6+len(main_croupier), row=2)
        if debug == 1:
            print(score_joueur, score_croupier)
            print('fin manche dans resultat')
        calcul_gain(consequence, assurance_gagnante)
        boucle -= 1
        if split != 0:
            # La désincrémetation de split permet de calculer la deuxième main
            # du joueur
            split -= 1


def calcul_gain(consequence=0, assurance_gagnante=0):
    """Calcul des gains

    Cette fonction sert à calculer les gains en fonction du résultat

    Parametres
    ----------.
    consequence : str
        Permet de déterminer combien le joueur a remporté en fonction du
        résultat
    assurance_gagnante : int
        Si le paramètre vaut 1, alors le joueur a pris l'assurance lorsqu'il a
        été dévoilé que la première carte du croupier était un As et le
        croupier a effectivement eu un blackjack
    """
    global mise_totale
    global argent_joueur
    if debug == 1:
        print('début calcul gain')
    # gain correspond à l'argent gagné grâce à la main
    gain = 0
    # gain assurance correspond à l'argent gagnée si le joueur a pris
    # l'assurance et que le croupier avait effectivement un blackjack
    gain_assurance = 0
    # Si le joueur n'a ni perdu ni abandonnée, il regagne sa mise de départ
    if consequence != 0 and consequence != 'ff':
        if debug == 1:
            print('mise remboursée')
        argent_joueur += mise_totale
        argent['text'] = f'Crédits: {int(argent_joueur)}'
    # Gain en cas de blackjack
    if consequence == 'Blackjack':
        gain += mise_totale * 1.5
    # Remboursement de la moitié de la mise en cas d'abandon
    if consequence == 'ff':
        gain += mise_totale // 2
    # Gain en cas de main meilleure que celle du croupier
    if consequence == 'win':
        gain += mise_totale
    # Gain relatif à l'assurance
    if assurance_gagnante == 1:
        gain_assurance += mise_totale
    gain = int(gain)
    if gain != 0:
        argent['text'] = f'Crédits: {int(argent_joueur)} + {int(gain)}'
    else:
        argent['text'] = f'Crédits: {int(argent_joueur)}'
    if gain_assurance != 0:
        argent['text'] += f' + {int(gain_assurance)}'
    argent_joueur += gain + gain_assurance
    # on vérifie si le joueur est en capacité de rembourser sa dette, c'est à
    # dire est qu'il possède le double du montant de sa dette
    test_dette()
    if debug == 1:
        print('fin calcul gain')
    fin_manche()


def splitter():
    """Splitter.

    Cette fonction permet au joueur de jouer deux main au lieu d'une seule si
    les deux premieres cartes reçues forment une paire. Si la paire en
    question est une paire d'As, le joueur ne reçois qu'une carte dans chacune
    des deux main et ne peut pas avoir de Blackjack
    """
    global split
    split = 1
    bouton_split.grid_forget()
    # cj1a et cj2a correspondent aux canvas permettant d'afficher sur
    # l'interface graphique des deux premières carte de la deuxième main du
    # joueur
    cj1a.grid(column=1, row=8)
    cj2a.grid(column=3, row=8)
    # La deuxième carte de la deuxième main disparait sur l'interface
    # graphique puisque correspondant désoirmais à la première carte de la
    # deuxième main
    cj2.delete('all')
    main_joueur_split.append(main_joueur[1])
    del main_joueur[1]
    main_joueur.append(paquet[0])
    del paquet[0]
    nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le paquet:' +\
        f' {str(len(paquet))} \nNombre de cartes restantes dans la' +\
        f' défausse: {str(len(defausse))}'
    main_joueur_split.append(paquet[0])
    del paquet[0]
    nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le paquet:' +\
        f' {str(len(paquet))} \nNombre de cartes restantes dans la' +\
        f' défausse: {str(len(defausse))}'
    creer_image(main_joueur_split[0], cj1a, 'cj1a')
    root.after(500, root.update())
    creer_image(main_joueur[1], cj2, 'cj2')
    root.after(500, root.update())
    creer_image(main_joueur_split[1], cj2a, 'cj2a')
    root.after(500, root.update())
    numero_main.grid(column=2, row=1)
    # Si le joueur a une paire d'as et qu'il split, il ne peut avoir que 2
    # cartes par main, as inclu. Son tour se finit donc automatiqument après
    # avoir reçu une carte supplémentaire par main
    if 'A' in main_joueur[0] and 'A' in main_joueur_split[0]:
        croupier()
    else:
        numero_main['text'] = 'Main 1'


def rejouer():
    """Rejouer.

    Cette fonction permet au joueur de jouer une nouvelle manche et fait
    disparaître les cartes ainsi que les différents textes qui apparaissent à
    la fin d'une manche. Si le nombre de cartes jouées est supérieur à la
    valeur de la coupe, alors le paquet et la défausse sont mis en commun et
    le nouveau paquet obtenu remélangé
    """
    global mise_totale
    global coupe
    global blackjack
    global nombre_partie
    # cc correspond à la liste de canvas permettant l'affichage des cartes du
    # croupier sur l'interface graphique
    global cc
    # cc correspond à la liste de canvas permettant l'affichage des cartes du
    # joueur sur l'interface graphique
    global cj
    blackjack = 0
    nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le paquet:' +\
        f' {str(len(paquet))} \nNombre de cartes restantes dans la' +\
        f' défausse: {str(len(defausse))}'
    # Si la carte rouge a été tirée
    if len(defausse) >= coupe:
        # Le reste du paquet et la défausse sont mis en commun
        for i in range(len(defausse)):
            paquet.append(defausse[0])
            del defausse[0]
            nb_carte_paquet['text'] = 'Nombre de cartes restantes dans le ' +\
                f'paquet: {str(len(paquet))} \nNombre de cartes restantes ' +\
                f'dans la défausse: {str(len(defausse))}'
        # Le paquet est remélangé et la carte rouge replacée dans ce dernier
        random.shuffle(paquet)
        coupe = random.randint(52, len(paquet)-52)
    bouton_rejouer.grid_forget()
    apparition_mise()
    bouton_donne_initiale.grid(column=2, row=3)
    mise_totale = 0
    mise_texte['text'] = "Mise totale: "
    argent['text'] = f'Crédits: {str(argent_joueur)}'
    # Les images des cartes disparaissent des l'interface graphqiue
    cc1.delete('all')
    cc2.delete('all')
    cj1.delete('all')
    cj2.delete('all')
    for i in range(2, 14):
        cc[i].grid_forget()
        cj[i].grid_forget()
        cja[i].grid_forget()
    resultat_label.grid_forget()
    resultat_final.grid_forget()
    assurance_valeur.grid_forget()
    stand_label.grid_forget()
    # Si le joueur n'a plus d'argent il lui est proposé de prendre un emprunt
    if argent_joueur == 0:
        emprunt.grid(column=9, row=5)
        term.grid(column=10, row=5)
        banque.grid(column=9, columnspan=5, row=3)


def quitter(event):
    """Quitter le jeu.

    Cette fonction permet au joueur de quitter le jeu et ferme la fenêtre du
    jeu
    """
    root.destroy()


# Les deux fonctions qui suivent servent à déterminer l'ordre d'appartion des
# widgets dans la fenêtre de jeu


def ordre_boutons2(event):
    if event.widget == bouton_melanger:
        bouton_melanger.grid_forget()
        bouton_donne_initiale.grid(column=2, row=3)
        apparition_mise()


def ordre_boutons3(event):
    if event.widget == bouton_donne_initiale:
        if mise_totale != 0:
            erreur.grid_forget()
            if debug == 1:
                print('ok')
            donne_initiale()
        else:
            bouton_donne_initiale.grid_forget()
            erreur.grid(column=2, row=3)
            erreur.lift()
            erreur['text'] = 'Veuillez miser pour jouer'


def apparition_bouton_joueur():
    """Apparition des boutons du joueur

    Cette fonction permet de faire apparaître sur l'interface graphique les
    boutons du joueur reltaifs aux actions qu'il peut effectuer vis à vis de
    sa main
    """
    global argent_joueur
    bouton_hit.grid(column=2, row=3)
    stand_bouton.grid(column=2, row=5)
    bouton_surrender.grid(column=2, row=6)
    # L'option double down n'est proposée au joueur que s'il possède encore
    # assez d'argent pour miser une seconde fois la même mise que la mise
    # qu'il vient de faire
    if argent_joueur >= mise_totale:
        bouton_double_down.grid(column=2, row=4)
    # Si les deux premières cartes du joueur forment une paire et qu'il
    # possède assez d'argent pour miser une seconde fois la même mise que la
    # mise qu'il vient de faire, il lui est proposé de splitter sa main
    if main_joueur[0][0] == main_joueur[1][0] and argent_joueur >= mise_totale:
        bouton_split.grid(column=2, row=7)
        argent_joueur -= mise_totale
        mise_texte['text'] == f'Mise main 1: {mise_totale} \n' +\
            f'Mise main 2: {mise_totale}'


def apparition_mise():
    """Apparition des mises

    Cette fonction permet de faire apparaitre les différents jetons relatifs
    aux mises sur l'interface graphique
    """
    jeton_blanc.grid(column=4, row=10)
    jeton_bleu.grid(column=3, row=10)
    jeton_rouge.grid(column=2, row=10)
    jeton_noir.grid(column=6, row=10)
    jeton_vert.grid(column=1, row=10)
    jeton_tapis.grid(column=7, row=10)
    miser.grid(column=0, row=10)
    mise_texte.grid(column=0, row=9)


def disparition_mise():
    """Disparition des mises

    Cette fonction permet de faire disparître les jetons relatifs aux mises
    sur l'interface graphique une fois que la manche a commencée
    """
    for i in range(len(jeton_et_mise)):
        jeton_et_mise[i].grid_forget()


def mise(montant_mise):
    """ Mise

    Cette fonction permet de comptabiliser la mise du joueur

    Parametres
    ----------.
    montant_mise: int
        Détermine de combien la mise doit être incrémentée
    """
    global mise_totale
    global argent_joueur
    if (argent_joueur - montant_mise) >= 0:
        erreur.grid_forget()
        bouton_donne_initiale.grid(column=2, row=3)
        mise_totale += montant_mise
        argent_joueur -= montant_mise
        mise_texte['text'] = f"Mise totale: {str(mise_totale)}"
        argent['text'] = f'Crédits: {str(argent_joueur)}'


def emprunter(event):
    """ Emprunt

    Cette fonction permet au joueur de faire un emprunt de crédit à la banque
    pour continuer de jouer
    """
    global argent_joueur
    global nombre_emprunt
    if event.widget == emprunt:
        nombre_emprunt += 1
        term.grid_forget()
        emprunt.grid_forget()
        valid.grid(column=9, columnspan=5, row=6)
        my_entry3.grid(column=9, columnspan=5, row=5)


def validd(event):
    """ Valider le montant de l'emprunt

    Cette fonction permet de valider le montant de l'emprunt effectué par le
    joueur et d'afficher une erreur si la saisie est hors du cadre requis
    """
    global argent_joueur
    global dette
    if event.widget == valid:
        if my_entry3.get() != int or int(my_entry3) <= 0:
            entry_label['text'] = 'Erreur\n Veuillez entrer' +\
                ' un nombre entier positif'
            entry_label.grid(column=9, columnspan=5, row=7)
        if my_entry3.get().isdigit():
            if debug == 1:
                print(entry_label.grid_info())
            argent_joueur += int(my_entry3.get())
            argent['text'] = f'Crédits: {str(argent_joueur)}'
            dette += int(my_entry3.get())
            dette_label['text'] = f'Vous avez {str(dette)} € de dettes ' +\
                'envers la banque'
            dette_label.grid(column=9, columnspan=5, row=2)
            for i in range(len(canvas_emprunt)):
                canvas_emprunt[i].grid_forget()


def test_dette():
    """ Vérifier combien le joueur a d'argent

    Cette fonction permet de vérifier si le joueur possède une somme au moins
    égale au double du montant de sa dette et la rembourse automatiquement si
    tel est le cas
    """
    global argent_joueur
    global dette
    if debug == 1:
        print('dette remboursable')
    # Vérifie que le joueur possède au moins le double du montant de la dette
    # et que le joueur est effectiement endettée
    if argent_joueur == 2*dette and dette != 0:
        argent_joueur = argent_joueur-dette
        dette = 0
        argent['text'] = f'Crédits: {str(argent_joueur)}'
        if debug == 1:
            print('dette remboursée')
        if dette == 0:
            dette_label['text'] = 'Vos dettes sont remboursées'
            dette_label['fg'] = 'red'
            dette_label.after(5000, lambda: dette_label.grid_forget())


"""interface pour permettre au joueur de comprendre les boutons et
graphismes"""

"""fonction pour afficher un tuto sur comment joueur"""


def tutoriel(event):
    if event.widget == bouton_tutoriel:
        interface = tkinter.Tk()
        interface.title('Tutoriel')
        interface.geometry == accueil.geometry
        interface.configure == root.configure
        interface.mainloop()


"""fenêtre pour afficher le recap du joeur en fin de partie"""


def recap_fin(event):
    global argent_joueur
    global nombre_partie
    global nom_joueur
    global nombre_emprunt
    if event.widget == bouton_quitter or event.widget == term:
        root.destroy()
        fen_recap = tkinter.Tk()
        fen_recap.title('Fin de jeu')
        fen_recap.geometry == accueil.geometry
        fen_recap.configure == root.configure
        recap1 = tkinter.Label(
            fen_recap, text='Voici votre récapitulatif de fin de partie')
        recap1.pack()
        recap = tkinter.Label(fen_recap, text=nom_joueur +
                              ', vous venez de quitter le jeu')
        recap.pack()
        recap5 = tkinter.Label(
            fen_recap, text='Vous avez commencé le jeu avec ' +
            f'{str(int(my_entry2))} crédits')
        recap5.grid()
        if nombre_partie > 1:
            recap2 = tkinter.Label(fen_recap, text='Vous avec terminé avec ' +
                                   f'{str(argent_joueur)} crédits\n Vous ' +
                                   f'avez réaliser {str(nombre_partie)} ' +
                                   'parties\n')
            recap2.pack()
        elif nombre_partie == 1 or nombre_partie == 0:
            recap2 = tkinter.Label(fen_recap, text='Vous avec terminé avec ' +
                                   f'{str(argent_joueur)} crédits\n Vous ' +
                                   f'avez réaliser {str(nombre_partie)} ' +
                                   'parties\n')
            recap2.pack()
        if nombre_emprunt != 0:
            recap3 = tkinter.Label(
                fen_recap, text=f'vous avez fait {str(nombre_emprunt)} ' +
                'emprunts\n')
            recap3.pack()
        if dette != 0:
            recap4 = tkinter.Label(fen_recap, text='Vous avez actuellement ' +
                                   f'{str(dette)} € de dettes ' +
                                   'envers la banque')
            recap4.pack()
        fermer = tkinter.Button(fen_recap, text='X', bg='red', fg='white',
                                command=quitter)
        fermer.pack(side='right', anchor='ne')
        fen_recap.mainloop()


"""Fenêtre accueil"""

accueil = tkinter.Tk()
accueil.title('Menu BlackJack 21')
accueil.geometry('700x600')
accueil.configure(bg='red')

# Variables relatives aux graphismes du jeu
"""Graphismes"""
"""configuration de l'écran d'acceuil"""


bj = tkinter.Label(text='BLACK JACK', bg='red', fg='gold',
                   font=('helvetica', 50))
bj.pack()

play = tkinter.Canvas(accueil, width=150, height=150, bg='red',
                      highlightthickness=0)
play.create_oval(1, 1, 145, 145, width=3, outline='mint cream',
                 fill='mint cream')
play.create_text(70, 75, text='Play', font=('elephant', 35), fill='black')

play.pack(padx=5, pady=5)

play.bind('<Button-1>', debut)
#placer l'image sur la fenêtre accueil
#copie code internet
image = Image.open("./Images/image0.png")
resize_image = image.resize((260, 220))
img = ImageTk.PhotoImage(resize_image)
label1 = tkinter.Label(bg='red',image=img)
label1.image = img
label1.pack(padx=5, pady=5)
""" entrée permettant au joueur de choisir son pseudo
ainsi que le nombre de crédit souhaité """

username = tkinter.Label(accueil, text="Username:",
                         font=('helvetica', 10), fg='black')
username.pack()

my_entry = tkinter.Entry(accueil)
my_entry.pack()

credit = tkinter.Label(accueil, text="Crédit:", font=('helvetica', 10),
                       fg='black')
credit.pack()

my_entry2 = tkinter.Entry(accueil)
my_entry2.pack()

"""graphisme fenêtre acceuil"""

cartes1 = tkinter.Canvas(accueil, width=100, height=160, bg='green')
cartes2 = tkinter.Canvas(accueil, width=100, height=160, bg='green')
cartes1.pack(side='left', anchor='n')
cartes2.pack(side='left', anchor='n')

cartes3 = tkinter.Canvas(accueil, width=100, height=160, bg='green')
cartes4 = tkinter.Canvas(accueil, width=100, height=160, bg='green')
cartes3.pack(side='right', anchor='n')
cartes4.pack(side='right', anchor='n')

jetonnoir = tkinter.Canvas(accueil, bg='red', width=60, height=60,
                           relief='raised', borderwidth=0,
                           highlightthickness=0)
jetonnoir.create_oval(1, 1, 55, 55, width=3, outline='gray19', fill='gray14')
jetonnoir.pack(side='left', anchor='center')
jetonnoir.place(bordermode='outside', relx=0.05, rely=0.1, anchor='nw')

jetonbleu = tkinter.Canvas(accueil, bg='red', width=60, height=60,
                           relief='raised', borderwidth=0,
                           highlightthickness=0)
jetonbleu.create_oval(1, 1, 55, 55, width=3, outline='blue4', fill='navy')
jetonbleu.pack(side='left', anchor='center')
jetonbleu.place(bordermode='outside', relx=0, rely=0, anchor='nw')

jetonblanc = tkinter.Canvas(accueil, bg='red', width=60, height=60,
                            relief='raised', borderwidth=0,
                            highlightthickness=0)
jetonblanc.create_oval(1, 1, 55, 55, width=3,
                       outline='light grey', fill='mint cream')
jetonblanc.pack(side='left', anchor='n')
jetonblanc.place(bordermode='outside', relx=0.1, rely=0, anchor='nw')

accueil.mainloop()


"""fenêtre root"""
root = tkinter.Tk()
root.title('Blackjack 21')
"""root.state('zoomed')"""

root.geometry = accueil.geometry
root.configure(bg="dark green")


def dir_regles(event):
    """ fonction associée au bouton comment joueur
    permettant au joueur de connaître les règle du jeu"""
    if event.widget == bouton_rdj:
        règle = tkinter.Tk()
        règle.title('Règle du jeu')
        règle.geometry = accueil.geometry
        règle.configure(bg='white')
        titre = tkinter.Label(règle, text='REGLE DU BLACKJACK 21\n',
                              bg='white', fg='black', font=('helvetica', 23))
        titre.pack(side='top')
        jeu = tkinter.Label(règle, text='Le BlackJack se joue avec 312 ' +
                            'cartes. 6 jeux de 52 cartes.\n',
                            bg='white', fg='gray13', font=('helvetica', 15))
        jeu.pack(side='top')

        valeurs_cartes = tkinter.Label(règle, text='Valeur des cartes',
                                       bg='white', fg='black',
                                       font=('helvetica', 17))
        valeurs_cartes.pack(side='top')

        points_cartes = tkinter.Label(règle, text='de 2 à 9 : valeur '
                                      'nominale de la carte\n de 10 au roi' +
                                      '(surnommées « bûche ») : 10 points' +
                                      '\n as : 1 ou 11 points (au choix ' +
                                      'du joueur)\n Le but du joueur ' +
                                      'est d’obtenir exactement 21 points.\n',
                                      bg='white', fg='gray13',
                                      font=('helvetica', 15))
        points_cartes.pack(side='top')

        deroulement_partie = tkinter.Label(règle, text='Déroulement d’une ' +
                                           'partie', bg='white', fg='black',
                                           font=('helvetica', 17))
        deroulement_partie.pack(side='top')

        deroulement_partie_texte = tkinter.Label(règle, text='Au début du ' +
                                                 'jeu, 2 cartes sont ' +
                                                 'distribuées au Player.\n' +
                                                 'A chaque tour, le Player ' +
                                                 'peut prendre des actions.' +
                                                 '\n Le Dealer pioche ' +
                                                 'jusqu’à atteindre 17 '
                                                 'points minimum.\n',
                                                 bg='white', fg='grey13',
                                                 font=('helvetica', 15))
        deroulement_partie_texte.pack(side='top')

        gagnant_texte = tkinter.Label(règle, text='Comment gagner ?',
                                      bg='white', fg='black',
                                      font=('helvetica', 17))
        gagnant_texte.pack(side='top')

        gagnanttexte = tkinter.Label(règle, text='Si le Dealer possède une ' +
                                     'main supérieure à 21, vous gagnez la ' +
                                     ' partie en cours. Vous gagnez 150% ' +
                                     'de votre mise.\n Si le Dealer a une ' +
                                     'main comprise entre 17 et 21 points, ' +
                                     'et que vous avez un score supérieur ' +
                                     'alors vous gagnez.\n Si vous avez ' +
                                     'une main supérieure à 21 points, ' +
                                     'vous perdez votre mise.\n En cas ' +
                                     'd’égalité, vous serez remboursé.\n',
                                     bg='white', fg='gray13',
                                     font=('helvetica', 15))

        gagnanttexte.pack(side='top')

        action = tkinter.Label(règle, text='Actions', bg='white',
                               fg='black', font=('helvetica', 17))
        action.pack(side='top')
        action_texte = tkinter.Label(règle, text='Hit : vous piochez autant ' +
                                     'de cartes souhaitées pour se ' +
                                     'rapprocher de 21\n Stand : le Player ' +
                                     'conserve ses cartes, il annonce s’il ' +
                                     'reste ou s’il s’arrête\n Double Down ' +
                                     ': le Player double sa mise, mais ' +
                                     'ne peut recevoir qu’une seule carte\n' +
                                     'Surrender : le Player abandonne et ' +
                                     'perd la moitié de sa mise',
                                     bg='white', fg='gray13',
                                     font=('helvetica', 15))
        action_texte.pack(side='top')

        def revenir(event):
            """fonction pour revenir au jeu et de
            quitter la fenêtre lorsque
            le bouton est appuyée"""
            if event.widget == bouton_revenir:
                règle.destroy()
        bouton_revenir = tkinter.Button(règle, text='Revenir au jeu', fg='red')
        bouton_revenir.pack()
        bouton_revenir.bind('<Button-1>', revenir)
    règle.mainloop()


erreur = tkinter.Label(root, text='', font=('helvetica', 10),
                       fg='black')

cartes = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
dos_carte(cartes, 'cartes')
cartes.grid(column=2, row=3)


"""Boutons"""
"""Ensemble des widgets utilisés dans la fenêtre root"""

"""bouton pour accéder aux règles du jeu"""
bouton_rdj = tkinter.Button(root, text='règle du jeu',
                            width=13, height=2, fg='navy',
                            font=('helvetica', 10))
bouton_rdj.grid(column=0, row=0)
bouton_rdj.bind('<Button-1>', dir_regles)

"""bouton pour quitter la partie"""
bouton_quitter = tkinter.Button(text='Quitter la partie', fg='red')
bouton_quitter.grid(column=2, row=11)
bouton_quitter.bind('<Button-1>', recap_fin)

"""mélanger le jeu de carte"""
bouton_melanger = tkinter.Button(
    text='Mélanger', fg='blue', command=random.shuffle(paquet))
bouton_melanger.grid(column=2, row=3)
bouton_melanger.bind('<Button-1>', ordre_boutons2)

"""bouton pour distribuer le jeu de carte"""
bouton_donne_initiale = tkinter.Button(
    text='Donne initiale', fg="blue")
bouton_donne_initiale.bind('<Button-1>', ordre_boutons3)

"""bouton qui relance la partie sans quitter le jeu"""
bouton_rejouer = tkinter.Button(
    text='Rejouer', fg="blue", command=rejouer)

"""bouton qui permet de piocher"""
bouton_hit = tkinter.Button(bg='white', text='Hit')
bouton_hit.bind('<Button-1>', lambda e: hit(main_joueur, 'main_joueur'))

"""bouton qui permet de 'double down'"""
bouton_double_down = tkinter.Button(bg='white', text='Double Down')
bouton_double_down.bind('<Button-1>', lambda e: doubble_down(
    main_joueur))

"""bouton qui permet de 'stand'"""
stand_bouton = tkinter.Button(bg='salmon', text='Stand')
stand_bouton.bind(
    "<Button-1>", lambda e: stand())

"""bouton qui permet de 'surrender'"""
bouton_surrender = tkinter.Button(bg='red', text='Surrender')
bouton_surrender.bind('<Button-1>', lambda e: surrender())

"""bouton qui 'split'"""
bouton_split = tkinter.Button(text='Split', command=splitter)

bouton_joueur = [bouton_hit, stand_bouton, bouton_surrender,
                 bouton_double_down]


texte_assurance = tkinter.Label(text='')

"""widgets pour l'assurance"""
bouton_oui_assurance = tkinter.Button(text='Oui')
bouton_non_assurance = tkinter.Button(text='Non')

bouton_oui_assurance.bind(
    '<Button-1>', lambda e: reponse_assurance(reponse='oui'))
bouton_non_assurance.bind(
    '<Button-1>', lambda e: reponse_assurance(reponse='non'))

assurance_valeur = tkinter.Label(text='')

"""widgets associés à l'emprunt + dettes"""
valid = tkinter.Button(root, text='valider l\'emprunt',
                       bg='dark green', fg='black')
valid.bind('<Button-1>', validd)
banque = tkinter.Label(root, text='Vous êtes à cours de crédit',
                       font=('helvetica', 15), bg='dark green',
                       fg='red')
emprunt = tkinter.Button(root, text='Emprunt')
emprunt.bind('<Button-1>', emprunter)
term = tkinter.Button(root, text='Terminer')
term.bind('<Button-1>', recap_fin)

eprnt = tkinter.Label(root, text='Combien souhaitez-vous ' +
                      'emprunter ?', fg='black',
                      bg='dark green')
my_entry3 = tkinter.Entry(root)

entry_label = tkinter.Label(root, text='', bg='dark green', fg='red')

canvas_emprunt = [my_entry3, valid, banque, eprnt, entry_label]

dette_label = tkinter.Label(root, text='', bg='dark green', fg='black',
                            font=('helvetica', 10))

"""bouton qui permet l'accès au tutoriel"""
bouton_tutoriel = tkinter.Button(root, text='Comment jouer ?',
                                 bg='green', fg='white',
                                 width=13, height=2,
                                 font=('helvetica', 10))
bouton_tutoriel.grid(column=1, row=0)
bouton_tutoriel.bind('<Button-1>', tutoriel)

""" mise du jeu """

mise_totale = 0
mise_valeur = {'jeton_vert': 1, 'jeton_rouge': 10, 'jeton_bleu': 25,
               'jeton_blanc': 50, 'jeton_noir': 100, 'tapis': 'argent_joueur'}

""" widgets associés à la mise du joueur"""

argent = tkinter.Label(root, text='Crédits: '+str(argent_joueur),
                       bg='dark green', fg='white')
argent.grid(column=0, row=8)

mise_texte = tkinter.Label(
    root, text='Mise totale: ', bg='dark green', fg='white')

miser = tkinter.Label(root, text="Cliquez pour miser:",
                      bg='dark green', fg='white')

""" position des widgets jetons pour la mise"""
jeton_tapis = tkinter.Canvas(root, bg='dark green', width=60, height=45,
                             relief='raised', borderwidth=0,
                             highlightthickness=0)
jeton_tapis.create_text(26, 21, text='All in',
                        font=('helvetica', 12), fill='white')
jeton_tapis.create_oval(4, 4, 50, 40, width=3,
                        outline='white')

jeton_blanc = tkinter.Canvas(root, bg='dark green', width=30, height=30,
                             relief='raised', borderwidth=0,
                             highlightthickness=0)
jeton_blanc.create_oval(1, 1, 25, 25, width=3,
                        outline='chartreuse4', fill='green4')

jeton_blanc.create_text(13, 13, text='50', font=('helvetica', 8), fill='white')

jeton_bleu = tkinter.Canvas(root, bg='dark green', width=30, height=30,
                            relief='raised', borderwidth=0,
                            highlightthickness=0)
jeton_bleu.create_oval(1, 1, 25, 25, width=3, outline='blue4', fill='navy')
jeton_bleu.create_text(13, 13, text='25', font=('helvetica', 8), fill='white')

jeton_rouge = tkinter.Canvas(root, bg='dark green', width=30, height=30,
                             relief='raised', borderwidth=0,
                             highlightthickness=0)
jeton_rouge.create_oval(1, 1, 25, 25, width=3, outline='brown4', fill='red')
jeton_rouge.create_text(13, 13, text='10', font=('helvetica', 8), fill='white')

jeton_noir = tkinter.Canvas(root, bg='dark green', width=30, height=30,
                            relief='raised', borderwidth=0,
                            highlightthickness=0)
jeton_noir.create_oval(1, 1, 25, 25, width=3, outline='gray19', fill='gray14')
jeton_noir.create_text(13, 13, text='100', font=('helvetica', 8), fill='white')

jeton_vert = tkinter.Canvas(root, bg='dark green', width=30, height=30,
                            relief='raised', borderwidth=0,
                            highlightthickness=0)
jeton_vert.create_oval(1, 1, 25, 25, width=3, outline='light grey',
                       fill='mint cream')
jeton_vert.create_text(13, 13, text='1', font=('helvetica', 8), fill='black')

"""commande d'incrémentation de mise"""

jeton_vert.bind('<Button-1>', lambda e: mise(1))

jeton_rouge.bind('<Button-1>', lambda e: mise(10))

jeton_bleu.bind('<Button-1>', lambda e: mise(25))

jeton_blanc.bind('<Button-1>', lambda e: mise(50))

jeton_noir.bind('<Button-1>', lambda e: mise(100))

jeton_tapis.bind('<Button-1>', lambda e: mise(argent_joueur))

jeton_et_mise = [jeton_vert, jeton_blanc, jeton_bleu, jeton_rouge, jeton_noir,
                 jeton_tapis, miser]

"""interface graphique"""


# interface emplacement des cartes 1 et 2 du joueur
cj1 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj1.grid(column=1, row=7)
cj2 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj2.grid(column=3, row=7)

# interface emplacement des cartes 1 et 2 du croupier
cc1 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cc1.grid(column=1, row=1)
cc2 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cc2.grid(column=3, row=1)

# texte qui définit le côté du croupier
labelc = tkinter.Label(root, text="Dealer ", font=(
    "helvetica", "15"), bg="dark green", fg="black")
labelc.grid(column=0, row=1)

# texte qui définit le côté du joueur
labelj = tkinter.Label(root, text=nom_joueur, font=("helvetica", "15"),
                       bg="dark green", fg="black")
labelj.grid(column=0, row=7)

"""cartes cachées dans la pioche"""
cj3 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj4 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj5 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj6 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj7 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj8 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj9 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj10 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj11 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj12 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj13 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj14 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')

cj1a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj2a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj3a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj4a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj5a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj6a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj7a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj8a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj9a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj10a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj11a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj12a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj13a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cj14a = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')

cc3 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cc4 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cc5 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cc6 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cc7 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cc8 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cc9 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cc10 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cc11 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cc12 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cc13 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')
cc14 = tkinter.Canvas(root, width=66, height=100, bg='#55AA55')

cj = [cj1, cj2, cj3, cj4, cj5, cj6, cj7, cj8, cj9, cj10, cj11, cj12, cj13,
      cj14]
cja = [cj1a, cj2a, cj3a, cj4a, cj5a, cj6a, cj7a, cj8a, cj9a, cj10a, cj11a,
       cj12a, cj13a, cj14a]
cc = [cc1, cc2, cc3, cc4, cc5, cc6, cc7, cc8, cc9, cc10, cc11, cc12, cc13,
      cc14]

numero_main = tkinter.Label(root, text='')

"""label pour afficher l'action du joueur"""
stand_label = tkinter.Label(root, bg='dark green', fg='black',
                            text="<<Je m'arrête>>",
                            font=("helvetica", "15"))
resultat_final = tkinter.Label(
    root, text='annonce', bg='dark green', fg='red')
resultat_label = tkinter.Label(
    root, text='', bg='dark green', fg='yellow')

"""label qui affiche le nombre de cartes restantes"""
nb_carte_paquet = tkinter.Label(
    root, text='Nombre de cartes restantes dans le paquet:' +
    f' {str(len(paquet))} \nNombre de cartes restantes dans la' +
    f'défausse: {str(len(defausse))}', bg='dark green')
nb_carte_paquet.grid(column=10, row=0)

root.mainloop()
